<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETHval Admin v7.0 - Schema Aligned</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { --bg: #0a0a0f; --bg-card: #12121a; --bg-hover: #1a1a25; --border: #2a2a3a; --text: #e5e5e5; --text-muted: #888; --primary: #8b5cf6; --success: #22c55e; --warning: #f59e0b; --error: #ef4444; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; padding: 20px; }
        .container { max-width: 1600px; margin: 0 auto; }
        .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px; padding-bottom: 20px; border-bottom: 1px solid var(--border); flex-wrap: wrap; gap: 16px; }
        .header h1 { font-size: 24px; font-weight: 700; }
        .badge { background: var(--primary); color: white; font-size: 10px; padding: 4px 8px; border-radius: 4px; font-weight: 600; margin-left: 12px; }
        .header-actions { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: all 0.2s; }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: #7c3aed; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: black; }
        .btn-secondary { background: var(--bg-card); color: var(--text); border: 1px solid var(--border); }
        .btn-sm { padding: 6px 12px; font-size: 12px; }
        .connection-status { display: flex; align-items: center; gap: 6px; padding: 6px 12px; border-radius: 20px; font-size: 12px; background: var(--bg-card); border: 1px solid var(--border); cursor: pointer; }
        .connection-status.connected { border-color: var(--success); color: var(--success); }
        .connection-status.disconnected { border-color: var(--error); color: var(--error); }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin-bottom: 24px; }
        .stat-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; text-align: center; }
        .stat-card .label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; margin-bottom: 4px; }
        .stat-card .value { font-size: 28px; font-weight: 700; }
        .stat-card .value.success { color: var(--success); }
        .stat-card .value.warning { color: var(--warning); }
        .stat-card .value.error { color: var(--error); }
        .table-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; overflow: hidden; margin-bottom: 24px; }
        .section-title { font-size: 16px; font-weight: 600; padding: 16px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg); font-size: 11px; text-transform: uppercase; color: var(--text-muted); font-weight: 600; }
        tr:last-child td { border-bottom: none; }
        tr:hover td { background: var(--bg-hover); }
        .mono { font-family: 'JetBrains Mono', monospace; font-size: 12px; }
        .table-name { font-family: 'JetBrains Mono', monospace; font-size: 10px; color: var(--text-muted); }
        .status { display: inline-flex; align-items: center; gap: 4px; padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; }
        .status.ok { background: rgba(34, 197, 94, 0.15); color: var(--success); }
        .status.warn { background: rgba(245, 158, 11, 0.15); color: var(--warning); }
        .status.fail { background: rgba(239, 68, 68, 0.15); color: var(--error); }
        .progress { width: 100%; height: 6px; background: var(--bg); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; border-radius: 3px; transition: width 0.3s; }
        .log-container { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
        .log { font-family: 'JetBrains Mono', monospace; font-size: 12px; height: 300px; overflow-y: auto; white-space: pre-wrap; background: var(--bg); padding: 12px; border-radius: 8px; }
        .log .success { color: var(--success); }
        .log .error { color: var(--error); }
        .log .warn { color: var(--warning); }
        .log .info { color: var(--primary); }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; justify-content: center; align-items: center; }
        .modal.show { display: flex; }
        .modal-content { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; max-width: 900px; width: 90%; max-height: 80vh; overflow-y: auto; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
        .modal-header h2 { font-size: 18px; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 24px; cursor: pointer; }
        .verify-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .verify-table th, .verify-table td { padding: 10px 12px; text-align: left; border-bottom: 1px solid var(--border); }
        .verify-table th { background: var(--bg); font-size: 11px; text-transform: uppercase; color: var(--text-muted); }
        .verify-match { color: var(--success); }
        .verify-mismatch { color: var(--error); }
        .verify-skip { color: var(--text-muted); }
        .diff-good { color: var(--success); }
        .diff-warn { color: var(--warning); }
        .diff-bad { color: var(--error); }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš¡ ETHval Admin <span class="badge">v7.0</span></h1>
            <div class="header-actions">
                <div class="connection-status" id="connStatus" onclick="showConfig()">
                    <span>â—</span>
                    <span id="connText">Connecting...</span>
                </div>
                <button class="btn btn-secondary" onclick="showConfig()">âš™ï¸ Config</button>
                <button class="btn btn-success" onclick="collectAll()">ğŸš€ Collect All 29</button>
                <button class="btn btn-primary" onclick="verifyAll()">ğŸ” Verify All</button>
                <button class="btn btn-secondary" onclick="refreshData()">ğŸ”„ Refresh</button>
            </div>
        </div>
        <div class="stats-grid">
            <div class="stat-card"><div class="label">Total</div><div class="value">29</div></div>
            <div class="stat-card"><div class="label">OK</div><div class="value success" id="statOk">-</div></div>
            <div class="stat-card"><div class="label">Partial</div><div class="value warning" id="statPartial">-</div></div>
            <div class="stat-card"><div class="label">Failed</div><div class="value error" id="statFailed">-</div></div>
            <div class="stat-card"><div class="label">Records</div><div class="value" id="statRecords">-</div></div>
        </div>
        <div class="table-container">
            <div class="section-title"><span>ğŸ“Š 29 Datasets</span><span class="mono" id="lastUpdate">-</span></div>
            <table><thead><tr><th>#</th><th>Dataset</th><th>Table</th><th>Records</th><th>Date Range</th><th>Value</th><th>Coverage</th><th>Status</th><th>Actions</th></tr></thead><tbody id="dataTable"></tbody></table>
        </div>
        <!-- CSV Upload Section -->
        <div class="table-container" style="margin-bottom: 24px;">
            <div class="section-title">
                <span>ğŸ“ Etherscan CSV Import (One-time Setup for Historical Data)</span>
                <button class="btn btn-sm btn-primary" onclick="autoFillNewData()">ğŸ”„ Auto-fill New Data</button>
            </div>
            <div style="padding: 20px;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 16px; margin-bottom: 16px;">
                    <!-- Daily ETH Burnt -->
                    <div class="csv-upload-box" id="dropBurn" ondrop="handleDrop(event, 'burn')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸ”¥</div>
                        <div class="csv-title">Daily ETH Burnt</div>
                        <a href="https://etherscan.io/chart/dailyethburnt" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileBurn" accept=".csv" onchange="handleFile(event, 'burn')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileBurn').click()">Select CSV</button>
                        <div class="csv-status" id="statusBurn">No file</div>
                    </div>
                    <!-- Daily Transactions -->
                    <div class="csv-upload-box" id="dropTx" ondrop="handleDrop(event, 'tx')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸ“</div>
                        <div class="csv-title">Daily Transactions</div>
                        <a href="https://etherscan.io/chart/tx" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileTx" accept=".csv" onchange="handleFile(event, 'tx')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileTx').click()">Select CSV</button>
                        <div class="csv-status" id="statusTx">No file</div>
                    </div>
                    <!-- Gas Price -->
                    <div class="csv-upload-box" id="dropGas" ondrop="handleDrop(event, 'gas')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">â›½</div>
                        <div class="csv-title">Avg Gas Price</div>
                        <a href="https://etherscan.io/chart/gasprice" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileGas" accept=".csv" onchange="handleFile(event, 'gas')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileGas').click()">Select CSV</button>
                        <div class="csv-status" id="statusGas">No file</div>
                    </div>
                    <!-- Total Supply -->
                    <div class="csv-upload-box" id="dropSupply" ondrop="handleDrop(event, 'supply')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸ’</div>
                        <div class="csv-title">Total Supply</div>
                        <a href="https://etherscan.io/chart/ethersupply" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileSupply" accept=".csv" onchange="handleFile(event, 'supply')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileSupply').click()">Select CSV</button>
                        <div class="csv-status" id="statusSupply">No file</div>
                    </div>
                    <!-- Daily Issuance -->
                    <div class="csv-upload-box" id="dropDailyIssuance" ondrop="handleDrop(event, 'dailyIssuance')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸª™</div>
                        <div class="csv-title">Daily Issuance</div>
                        <a href="#" onclick="alert('Use generated CSV from Claude or download from ultrasound.money'); return false;" class="csv-link">ğŸ“¥ Get CSV</a>
                        <input type="file" id="fileDailyIssuance" accept=".csv" onchange="handleFile(event, 'dailyIssuance')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileDailyIssuance').click()">Select CSV</button>
                        <div class="csv-status" id="statusDailyIssuance">No file</div>
                    </div>
                    <!-- Blob Data (Dune) -->
                    <div class="csv-upload-box" id="dropBlob" ondrop="handleDrop(event, 'blob')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸ«§</div>
                        <div class="csv-title">Blob Data (Dune)</div>
                        <a href="https://dune.com/queries/new" target="_blank" class="csv-link">ğŸ“¥ Query Dune</a>
                        <input type="file" id="fileBlob" accept=".csv" onchange="handleFile(event, 'blob')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileBlob').click()">Select CSV</button>
                        <div class="csv-status" id="statusBlob">No file</div>
                    </div>
                    <!-- Gas Utilization -->
                    <div class="csv-upload-box" id="dropGasUtil" ondrop="handleDrop(event, 'gasUtil')" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <div class="csv-icon">ğŸ“Š</div>
                        <div class="csv-title">Gas Utilization</div>
                        <a href="https://etherscan.io/chart/networkutilization" target="_blank" class="csv-link">ğŸ“¥ Download CSV</a>
                        <input type="file" id="fileGasUtil" accept=".csv" onchange="handleFile(event, 'gasUtil')" style="display:none">
                        <button class="btn btn-sm btn-secondary" onclick="document.getElementById('fileGasUtil').click()">Select CSV</button>
                        <div class="csv-status" id="statusGasUtil">No file</div>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                    <button class="btn btn-success" id="importBtn" onclick="importAllCSV()" disabled>ğŸ“¥ Import All to Supabase</button>
                    <span id="importProgress" style="color: var(--text-muted); font-size: 13px;"></span>
                </div>
                <div style="margin-top: 12px; padding: 12px; background: var(--bg); border-radius: 8px; font-size: 12px; color: var(--text-muted);">
                    ğŸ’¡ <b>How to get CSV:</b> Visit each Etherscan chart page â†’ Click "Download: CSV Data" link at top â†’ Upload here<br>
                    ğŸ”„ <b>Auto-fill:</b> After CSV import, click "Auto-fill New Data" to calculate missing days using block data
                </div>
            </div>
        </div>
        
        <style>
            .csv-upload-box { 
                border: 2px dashed var(--border); 
                border-radius: 12px; 
                padding: 20px; 
                text-align: center; 
                transition: all 0.2s;
                cursor: pointer;
            }
            .csv-upload-box:hover, .csv-upload-box.dragover { 
                border-color: var(--primary); 
                background: rgba(139, 92, 246, 0.1); 
            }
            .csv-upload-box.loaded { 
                border-color: var(--success); 
                background: rgba(34, 197, 94, 0.1); 
            }
            .csv-icon { font-size: 32px; margin-bottom: 8px; }
            .csv-title { font-weight: 600; margin-bottom: 4px; }
            .csv-desc { font-size: 11px; color: var(--text-muted); margin-bottom: 12px; }
            .csv-link { display: block; font-size: 11px; color: var(--primary); text-decoration: none; margin-bottom: 10px; }
            .csv-link:hover { text-decoration: underline; }
            .csv-status { margin-top: 10px; font-size: 11px; color: var(--text-muted); }
            .csv-status.success { color: var(--success); }
            .csv-status.error { color: var(--error); }
        </style>

        <div class="log-container">
            <div class="section-title">ğŸ“ Activity Log</div>
            <div class="log" id="log"></div>
        </div>
        
        <!-- Verify Modal -->
        <div class="modal" id="verifyModal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>ğŸ” Data Verification Results</h2>
                    <button class="modal-close" onclick="closeModal()">&times;</button>
                </div>
                <div id="verifyResults"></div>
            </div>
        </div>
        
        <!-- Config Modal -->
        <div class="modal" id="configModal">
            <div class="modal-content" style="max-width: 500px;">
                <div class="modal-header">
                    <h2>âš™ï¸ Configuration</h2>
                    <button class="modal-close" onclick="closeConfigModal()">&times;</button>
                </div>
                <div style="padding: 20px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Supabase URL</label>
                        <input type="text" id="configSupabaseUrl" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="https://xxxxx.supabase.co">
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Supabase Anon Key</label>
                        <input type="text" id="configSupabaseKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 5px; font-weight: 600;">Etherscan API Key <span style="font-weight: normal; opacity: 0.7;">(free at etherscan.io/apis)</span></label>
                        <input type="text" id="configEtherscanKey" style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--surface); color: var(--text);" placeholder="Optional - for transactions & gas data">
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="btn btn-secondary" onclick="closeConfigModal()">Cancel</button>
                        <button class="btn btn-success" onclick="saveConfig()">ğŸ’¾ Save & Reload</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let SUPABASE_URL = localStorage.getItem('ethval_supabase_url') || '';
        let SUPABASE_ANON_KEY = localStorage.getItem('ethval_supabase_key') || '';
        let ETHERSCAN_API_KEY = localStorage.getItem('ethval_etherscan_key') || '';
        let supabase;
        
        // CSV Data Storage
        const csvData = { burn: null, tx: null, gas: null, supply: null, dailyIssuance: null, blob: null, gasUtil: null };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CSV UPLOAD & PARSING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(e, type) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) processCSV(file, type);
        }
        
        function handleFile(e, type) {
            const file = e.target.files[0];
            if (file) processCSV(file, type);
        }
        
        function processCSV(file, type) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const text = e.target.result;
                    const lines = text.trim().split('\n');
                    const records = [];
                    
                    // Get header to understand column structure
                    const headerLine = lines[0];
                    console.log(`[${type}] Header:`, headerLine);
                    console.log(`[${type}] First data lines:`, lines.slice(1, 3));
                    
                    // Parse header
                    const headers = parseCSVLine(headerLine);
                    console.log(`[${type}] Parsed headers:`, headers);
                    
                    // Skip header, parse data
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const parts = parseCSVLine(line);
                        if (parts.length < 2) continue;
                        
                        const dateStr = parts[0];
                        let timestamp, value;
                        
                        // Handle different CSV formats
                        if (type === 'supply') {
                            // Supply Growth CSV: Date, UnixTimeStamp, TotalSupply
                            // We need to calculate daily change (issuance - burn = net change)
                            // Store raw total supply, we'll calculate daily issuance after parsing all records
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            value = parseFloat(parts[2].replace(/,/g, ''));
                            
                        } else if (type === 'dailyIssuance') {
                            // Daily Issuance CSV: date, daily_issuance, eth2_staking_cumulative
                            // ìš°ë¦¬ê°€ ìƒì„±í•œ CSV í˜•ì‹
                            value = parseFloat(parts[1].replace(/,/g, ''));
                            const cumulative = parts[2] ? parseFloat(parts[2].replace(/,/g, '')) : null;
                            
                            let dateObj;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                dateObj = new Date(`${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                            
                            // Store cumulative in record for later use
                            if (cumulative) {
                                records.push({ date: dateStr.includes('/') ? `${dateStr.split('/')[2]}-${dateStr.split('/')[0].padStart(2,'0')}-${dateStr.split('/')[1].padStart(2,'0')}` : dateStr, timestamp, value, cumulative });
                                continue;
                            }
                            
                        } else if (type === 'blob') {
                            // Dune Blob CSV: date, blob_count, blob_gas_used
                            // Date format: "2024-03-13 00:00:00.000 UTC"
                            const blobCount = parseInt(parts[1].replace(/,/g, ''));
                            const blobGasUsed = parseInt(parts[2].replace(/,/g, ''));
                            
                            // Parse Dune date format
                            let dateObj;
                            if (dateStr.includes(' ')) {
                                // "2024-03-13 00:00:00.000 UTC" -> "2024-03-13"
                                dateObj = new Date(dateStr.split(' ')[0]);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                            const isoDate = dateObj.toISOString().split('T')[0];
                            
                            records.push({ 
                                date: isoDate, 
                                timestamp: timestamp * 1000, // milliseconds
                                blob_count: blobCount,
                                blob_gas_used: blobGasUsed,
                                blob_fee_eth: 0, // Not available in Dune query
                                source: 'dune'
                            });
                            continue;
                            
                        } else if (type === 'gasUtil') {
                            // Etherscan Network Utilization CSV: Date, UnixTimeStamp, Value (decimal 0.xx)
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            value = parseFloat(parts[2].replace(/,/g, '')) * 100; // Convert 0.xx to percentage
                            
                            // Convert date format to ISO
                            let isoDate;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                isoDate = `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
                            } else {
                                isoDate = dateStr;
                            }
                            
                            records.push({ 
                                date: isoDate, 
                                timestamp, 
                                gas_utilization: parseFloat(value.toFixed(2))
                            });
                            continue;
                            
                        } else if (parts.length === 2) {
                            // 2-column format: Date, Value (no timestamp)
                            const valueStr = parts[1].replace(/,/g, '');
                            value = parseFloat(valueStr);
                            
                            let dateObj;
                            if (dateStr.includes('/')) {
                                const [m, d, y] = dateStr.split('/');
                                dateObj = new Date(`${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`);
                            } else {
                                dateObj = new Date(dateStr);
                            }
                            timestamp = Math.floor(dateObj.getTime() / 1000);
                        } else {
                            // 3-column format: Date, Timestamp, Value
                            timestamp = parseInt(parts[1].replace(/,/g, ''));
                            const valueStr = parts[2].replace(/,/g, '');
                            value = parseFloat(valueStr);
                        }
                        
                        if (isNaN(value)) {
                            continue;
                        }
                        
                        // Convert date format to ISO
                        let isoDate;
                        if (dateStr.includes('/')) {
                            const [m, d, y] = dateStr.split('/');
                            isoDate = `${y}-${m.padStart(2,'0')}-${d.padStart(2,'0')}`;
                        } else {
                            isoDate = dateStr;
                        }
                        
                        records.push({ date: isoDate, timestamp, value });
                    }
                    
                    csvData[type] = records;
                    
                    const typeMap = { burn: 'Burn', tx: 'Tx', gas: 'Gas', supply: 'Supply', dailyIssuance: 'DailyIssuance', blob: 'Blob', gasUtil: 'GasUtil' };
                    const statusEl = document.getElementById(`status${typeMap[type]}`);
                    const boxEl = document.getElementById(`drop${typeMap[type]}`);
                    
                    statusEl.textContent = `âœ“ ${records.length} records loaded`;
                    statusEl.className = 'csv-status success';
                    boxEl.classList.add('loaded');
                    
                    updateImportButton();
                    log(`ğŸ“ ${type.toUpperCase()}: Parsed ${records.length} records from CSV`, 'success');
                    
                } catch (err) {
                    console.error(`[${type}] Parse error:`, err);
                    const typeMap = { burn: 'Burn', tx: 'Tx', gas: 'Gas', supply: 'Supply', dailyIssuance: 'DailyIssuance', blob: 'Blob', gasUtil: 'GasUtil' };
                    const statusEl = document.getElementById(`status${typeMap[type]}`);
                    statusEl.textContent = `âœ— Parse error: ${err.message}`;
                    statusEl.className = 'csv-status error';
                    log(`âŒ ${type.toUpperCase()}: CSV parse error - ${err.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        // Helper function to parse CSV line with proper quote handling
        function parseCSVLine(line) {
            const parts = [];
            let current = '';
            let inQuotes = false;
            
            for (let c of line) {
                if (c === '"') {
                    inQuotes = !inQuotes;
                } else if (c === ',' && !inQuotes) {
                    parts.push(current.trim());
                    current = '';
                } else {
                    current += c;
                }
            }
            parts.push(current.trim());
            return parts;
        }
        
        function updateImportButton() {
            const btn = document.getElementById('importBtn');
            const loaded = Object.values(csvData).filter(v => v !== null).length;
            btn.disabled = loaded === 0;
            btn.textContent = `ğŸ“¥ Import ${loaded}/6 Files to Supabase`;
        }
        
        async function importAllCSV() {
            if (!supabase) {
                alert('Please configure Supabase first!');
                return;
            }
            
            const progressEl = document.getElementById('importProgress');
            let totalImported = 0;
            
            try {
                // Import Gas & Burn data (combined table)
                if (csvData.burn || csvData.gas) {
                    progressEl.textContent = 'Importing Gas & Burn data...';
                    
                    // Merge burn and gas data by date
                    const mergedData = new Map();
                    
                    if (csvData.burn) {
                        csvData.burn.forEach(r => {
                            mergedData.set(r.date, { 
                                date: r.date, 
                                eth_burnt: r.value,
                                avg_gas_price_gwei: 0,
                                transaction_count: 0
                            });
                        });
                    }
                    
                    if (csvData.gas) {
                        csvData.gas.forEach(r => {
                            // Convert Wei to Gwei (Etherscan exports in Wei)
                            const gasPriceGwei = r.value > 1e6 ? r.value / 1e9 : r.value;
                            
                            if (mergedData.has(r.date)) {
                                mergedData.get(r.date).avg_gas_price_gwei = gasPriceGwei;
                            } else {
                                mergedData.set(r.date, {
                                    date: r.date,
                                    eth_burnt: 0,
                                    avg_gas_price_gwei: gasPriceGwei,
                                    transaction_count: 0
                                });
                            }
                        });
                    }
                    
                    const gasRecords = Array.from(mergedData.values());
                    log(`ğŸ“¦ Gas/Burn: Merged ${gasRecords.length} records`, 'info');
                    
                    const { error: gasError } = await batchUpsert('historical_gas_burn', gasRecords);
                    if (gasError) throw new Error(`Gas/Burn: ${gasError.message}`);
                    
                    totalImported += gasRecords.length;
                    log(`âœ… Gas/Burn: Imported ${gasRecords.length} records`, 'success');
                }
                
                // Import Transactions
                if (csvData.tx) {
                    progressEl.textContent = 'Importing Transactions...';
                    
                    const txRecords = csvData.tx.map(r => ({
                        date: r.date,
                        timestamp: r.timestamp * 1000,
                        tx_count: Math.round(r.value)
                    }));
                    
                    const { error: txError } = await batchUpsert('historical_transactions', txRecords);
                    if (txError) throw new Error(`Transactions: ${txError.message}`);
                    
                    totalImported += txRecords.length;
                    log(`âœ… Transactions: Imported ${txRecords.length} records`, 'success');
                    
                    // Also update gas_burn table with tx counts
                    if (csvData.burn || csvData.gas) {
                        const txMap = new Map(csvData.tx.map(r => [r.date, Math.round(r.value)]));
                        const { data: gasData } = await supabase.from('historical_gas_burn')
                            .select('date, eth_burnt, avg_gas_price_gwei')
                            .order('date', { ascending: false })
                            .limit(2000);
                        
                        if (gasData) {
                            const updates = gasData
                                .filter(g => txMap.has(g.date))
                                .map(g => ({
                                    date: g.date,
                                    eth_burnt: g.eth_burnt,
                                    avg_gas_price_gwei: g.avg_gas_price_gwei,
                                    transaction_count: txMap.get(g.date)
                                }));
                            
                            if (updates.length > 0) {
                                await batchUpsert('historical_gas_burn', updates);
                                log(`âœ… Updated ${updates.length} gas_burn records with tx counts`, 'success');
                            }
                        }
                    }
                }
                
                // Import Supply data (Total Supply from CSV)
                if (csvData.supply) {
                    progressEl.textContent = 'Importing Supply data...';
                    
                    // Sort by date ascending
                    const sorted = [...csvData.supply].sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    // Store Total Supply in eth_supply column
                    // Note: Daily Issuance is calculated from staking APR in index.html, not from CSV
                    const supplyRecords = sorted.map(r => ({
                        date: r.date,
                        eth_supply: r.value  // Total supply from CSV
                        // eth2_staking is NOT set here - it will be calculated from APR
                    }));
                    
                    log(`ğŸ“¦ Supply: Importing ${supplyRecords.length} total supply records`, 'info');
                    
                    const { error: supplyError } = await batchUpsert('historical_eth_supply', supplyRecords);
                    if (supplyError) {
                        log(`âš ï¸ Supply save error: ${supplyError.message}`, 'warn');
                    } else {
                        log(`âœ… Supply: Imported ${supplyRecords.length} records`, 'success');
                    }
                    
                    totalImported += supplyRecords.length;
                }
                
                // Import Daily Issuance data (from generated CSV)
                if (csvData.dailyIssuance) {
                    progressEl.textContent = 'Importing Daily Issuance data...';
                    
                    const sorted = [...csvData.dailyIssuance].sort((a, b) => new Date(a.date) - new Date(b.date));
                    
                    const issuanceRecords = sorted.map(r => ({
                        date: r.date,
                        daily_issuance: r.value,
                        eth2_staking_cumulative: r.cumulative || null,
                        source: 'csv'
                    }));
                    
                    log(`ğŸ“¦ Daily Issuance: Importing ${issuanceRecords.length} records`, 'info');
                    
                    const { error: issuanceError } = await batchUpsert('historical_daily_issuance', issuanceRecords);
                    if (issuanceError) {
                        log(`âš ï¸ Daily Issuance save error: ${issuanceError.message}`, 'warn');
                    } else {
                        log(`âœ… Daily Issuance: Imported ${issuanceRecords.length} records`, 'success');
                    }
                    
                    totalImported += issuanceRecords.length;
                }
                
                // Import Blob data (from Dune CSV)
                if (csvData.blob) {
                    progressEl.textContent = 'Importing Blob data...';
                    
                    // blob records are already formatted correctly in processCSV
                    const blobRecords = csvData.blob;
                    
                    log(`ğŸ“¦ Blob Data: Importing ${blobRecords.length} records from Dune`, 'info');
                    
                    const { error: blobError } = await batchUpsert('historical_blob_data', blobRecords);
                    if (blobError) {
                        log(`âš ï¸ Blob Data save error: ${blobError.message}`, 'warn');
                    } else {
                        log(`âœ… Blob Data: Imported ${blobRecords.length} records`, 'success');
                    }
                    
                    totalImported += blobRecords.length;
                }
                
                // Import Gas Utilization data (from Etherscan CSV)
                if (csvData.gasUtil) {
                    progressEl.textContent = 'Importing Gas Utilization data...';
                    
                    const gasUtilRecords = csvData.gasUtil;
                    log(`ğŸ“¦ Gas Utilization: Updating ${gasUtilRecords.length} records`, 'info');
                    
                    // Update existing records in historical_gas_burn with gas_utilization
                    let updated = 0;
                    for (const record of gasUtilRecords) {
                        const { error } = await supabase.from('historical_gas_burn')
                            .update({ gas_utilization: record.gas_utilization, source: 'etherscan_csv' })
                            .eq('date', record.date);
                        if (!error) updated++;
                    }
                    
                    // For dates without existing gas_burn record, insert new record
                    const { data: existingDates } = await supabase.from('historical_gas_burn')
                        .select('date');
                    const existingSet = new Set(existingDates?.map(d => d.date) || []);
                    
                    const newRecords = gasUtilRecords
                        .filter(r => !existingSet.has(r.date))
                        .map(r => ({
                            date: r.date,
                            gas_utilization: r.gas_utilization,
                            eth_burnt: 0,
                            source: 'etherscan_csv'
                        }));
                    
                    if (newRecords.length > 0) {
                        const { error: insertError } = await batchUpsert('historical_gas_burn', newRecords);
                        if (insertError) {
                            log(`âš ï¸ Gas Utilization insert error: ${insertError.message}`, 'warn');
                        }
                    }
                    
                    log(`âœ… Gas Utilization: Updated ${updated}, inserted ${newRecords.length} records`, 'success');
                    totalImported += gasUtilRecords.length;
                }
                
                progressEl.textContent = `âœ“ Done! Imported ${totalImported} total records`;
                progressEl.style.color = 'var(--success)';
                
                // Refresh data display
                await refreshData();
                
            } catch (err) {
                progressEl.textContent = `âœ— Error: ${err.message}`;
                progressEl.style.color = 'var(--error)';
                log(`âŒ Import failed: ${err.message}`, 'error');
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUTO-FILL NEW DATA (Block-based calculation)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function autoFillNewData() {
            if (!supabase || !ETHERSCAN_API_KEY) {
                alert('Please configure Supabase and Etherscan API key first!');
                return;
            }
            
            log('ğŸ”„ Auto-fill: Starting...', 'info');
            
            try {
                // 1. Get the latest date from gas_burn table
                const { data: latestGas } = await supabase.from('historical_gas_burn')
                    .select('date')
                    .order('date', { ascending: false })
                    .limit(1);
                
                const { data: latestTx } = await supabase.from('historical_transactions')
                    .select('date')
                    .order('date', { ascending: false })
                    .limit(1);
                
                const lastGasDate = latestGas?.[0]?.date ? new Date(latestGas[0].date) : null;
                const lastTxDate = latestTx?.[0]?.date ? new Date(latestTx[0].date) : null;
                
                log(`ğŸ“… Last Gas/Burn date: ${lastGasDate?.toISOString().split('T')[0] || 'None'}`, 'info');
                log(`ğŸ“… Last Tx date: ${lastTxDate?.toISOString().split('T')[0] || 'None'}`, 'info');
                
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                // 2. Calculate missing dates
                const missingDates = [];
                if (lastGasDate) {
                    let d = new Date(lastGasDate);
                    d.setDate(d.getDate() + 1);
                    while (d < today) {
                        missingDates.push(new Date(d));
                        d.setDate(d.getDate() + 1);
                    }
                }
                
                if (missingDates.length === 0) {
                    log('âœ… Auto-fill: Data is up to date!', 'success');
                    return;
                }
                
                log(`ğŸ“Š Auto-fill: Need to fill ${missingDates.length} days`, 'info');
                
                // 3. For each missing date, calculate from block data
                const gasRecords = [];
                const txRecords = [];
                
                for (let i = 0; i < missingDates.length; i++) {
                    const date = missingDates[i];
                    const dateStr = date.toISOString().split('T')[0];
                    
                    log(`   Processing ${dateStr} (${i+1}/${missingDates.length})...`, 'info');
                    
                    // Get block range for this date
                    const startTime = Math.floor(date.getTime() / 1000);
                    const endTime = startTime + 86400 - 1;
                    
                    // Get start block
                    const startBlockUrl = `https://api.etherscan.io/api?module=block&action=getblocknobytime&timestamp=${startTime}&closest=after&apikey=${ETHERSCAN_API_KEY}`;
                    const startBlockRes = await fetch(startBlockUrl);
                    const startBlockData = await startBlockRes.json();
                    
                    // Get end block  
                    const endBlockUrl = `https://api.etherscan.io/api?module=block&action=getblocknobytime&timestamp=${endTime}&closest=before&apikey=${ETHERSCAN_API_KEY}`;
                    const endBlockRes = await fetch(endBlockUrl);
                    const endBlockData = await endBlockRes.json();
                    
                    if (startBlockData.status !== '1' || endBlockData.status !== '1') {
                        log(`   âš ï¸ Could not get blocks for ${dateStr}`, 'warn');
                        continue;
                    }
                    
                    const startBlock = parseInt(startBlockData.result);
                    const endBlock = parseInt(endBlockData.result);
                    const blockCount = endBlock - startBlock + 1;
                    
                    // Sample a few blocks to estimate gas metrics
                    const sampleBlocks = [];
                    const sampleSize = Math.min(20, blockCount);
                    const step = Math.floor(blockCount / sampleSize);
                    
                    for (let j = 0; j < sampleSize; j++) {
                        sampleBlocks.push(startBlock + j * step);
                    }
                    
                    let totalBaseFee = 0;
                    let totalGasUsed = 0;
                    let totalTxCount = 0;
                    let validSamples = 0;
                    
                    for (const blockNum of sampleBlocks) {
                        try {
                            const blockUrl = `https://api.etherscan.io/api?module=proxy&action=eth_getBlockByNumber&tag=0x${blockNum.toString(16)}&boolean=false&apikey=${ETHERSCAN_API_KEY}`;
                            const blockRes = await fetch(blockUrl);
                            const blockData = await blockRes.json();
                            
                            if (blockData.result) {
                                const baseFee = parseInt(blockData.result.baseFeePerGas || '0', 16);
                                const gasUsed = parseInt(blockData.result.gasUsed || '0', 16);
                                const txCount = (blockData.result.transactions || []).length;
                                
                                totalBaseFee += baseFee;
                                totalGasUsed += gasUsed;
                                totalTxCount += txCount;
                                validSamples++;
                            }
                        } catch (e) {
                            // Skip failed samples
                        }
                        
                        // Rate limiting
                        await new Promise(r => setTimeout(r, 220));
                    }
                    
                    if (validSamples > 0) {
                        const avgBaseFeeWei = totalBaseFee / validSamples;
                        const avgGasUsed = totalGasUsed / validSamples;
                        const avgTxPerBlock = totalTxCount / validSamples;
                        
                        // Extrapolate to full day
                        const dailyGasUsed = avgGasUsed * blockCount;
                        const dailyBurn = (avgBaseFeeWei * dailyGasUsed) / 1e18; // ETH
                        const dailyTx = Math.round(avgTxPerBlock * blockCount);
                        const avgGasGwei = avgBaseFeeWei / 1e9;
                        
                        gasRecords.push({
                            date: dateStr,
                            eth_burnt: parseFloat(dailyBurn.toFixed(2)),
                            avg_gas_price_gwei: parseFloat(avgGasGwei.toFixed(2)),
                            transaction_count: dailyTx
                        });
                        
                        txRecords.push({
                            date: dateStr,
                            timestamp: date.getTime(),
                            tx_count: dailyTx
                        });
                        
                        log(`   âœ“ ${dateStr}: ${dailyBurn.toFixed(1)} ETH burnt, ${avgGasGwei.toFixed(1)} Gwei, ${dailyTx.toLocaleString()} txs`, 'success');
                    }
                }
                
                // 4. Save to Supabase
                if (gasRecords.length > 0) {
                    const { error: gasError } = await batchUpsert('historical_gas_burn', gasRecords);
                    if (gasError) log(`âŒ Gas save error: ${gasError.message}`, 'error');
                    else log(`âœ… Saved ${gasRecords.length} gas/burn records`, 'success');
                }
                
                if (txRecords.length > 0) {
                    const { error: txError } = await batchUpsert('historical_transactions', txRecords);
                    if (txError) log(`âŒ Tx save error: ${txError.message}`, 'error');
                    else log(`âœ… Saved ${txRecords.length} transaction records`, 'success');
                }
                
                // 5. Auto-calculate issuance for missing dates
                await autoFillIssuance(missingDates);
                
                log(`ğŸ‰ Auto-fill complete! Filled ${gasRecords.length} days`, 'success');
                await refreshData();
                
            } catch (err) {
                log(`âŒ Auto-fill error: ${err.message}`, 'error');
            }
        }
        
        // Auto-fill missing supply data (eth_supply only, Daily Issuance is calculated from APR)
        async function autoFillIssuance(dates) {
            if (!dates || dates.length === 0) return;
            
            try {
                log('ğŸ’ Checking supply data...', 'info');
                
                // Check which dates already have data
                const dateStrs = dates.map(d => d.toISOString().split('T')[0]);
                const { data: existingData } = await supabase.from('historical_eth_supply')
                    .select('date, eth_supply')
                    .in('date', dateStrs);
                
                const existingDates = new Set(existingData?.map(d => d.date) || []);
                const missingDates = dates.filter(d => !existingDates.has(d.toISOString().split('T')[0]));
                
                if (missingDates.length === 0) {
                    log('   âœ… Supply data up to date', 'success');
                    return;
                }
                
                log(`   ğŸ“Š Auto-filling ${missingDates.length} missing supply days...`, 'info');
                
                // Get latest known supply
                const { data: latestSupply } = await supabase.from('historical_eth_supply')
                    .select('eth_supply')
                    .order('date', { ascending: false })
                    .limit(1);
                
                // Approximate current supply (slowly increasing/decreasing)
                const baseSupply = latestSupply?.[0]?.eth_supply || 120500000;
                
                const supplyUpdates = missingDates.map((date) => ({
                    date: date.toISOString().split('T')[0],
                    eth_supply: baseSupply  // Use latest known supply as approximation
                }));
                
                if (supplyUpdates.length > 0) {
                    const { error } = await batchUpsert('historical_eth_supply', supplyUpdates);
                    if (error) {
                        log(`   âš ï¸ Supply save error: ${error.message}`, 'warn');
                    } else {
                        log(`   âœ… Auto-filled ${supplyUpdates.length} supply records`, 'success');
                    }
                }
                
            } catch (err) {
                log(`   âš ï¸ Supply auto-fill error: ${err.message}`, 'warn');
            }
        }

        function showConfig() {
            document.getElementById('configSupabaseUrl').value = SUPABASE_URL;
            document.getElementById('configSupabaseKey').value = SUPABASE_ANON_KEY;
            document.getElementById('configEtherscanKey').value = ETHERSCAN_API_KEY;
            document.getElementById('configModal').classList.add('show');
        }
        
        function closeConfigModal() {
            document.getElementById('configModal').classList.remove('show');
        }
        
        function saveConfig() {
            const url = document.getElementById('configSupabaseUrl').value.trim();
            const key = document.getElementById('configSupabaseKey').value.trim();
            const etherscanKey = document.getElementById('configEtherscanKey').value.trim();
            
            if (!url || !key) {
                alert('Supabase URL and Key are required!');
                return;
            }
            
            localStorage.setItem('ethval_supabase_url', url);
            localStorage.setItem('ethval_supabase_key', key);
            if (etherscanKey) localStorage.setItem('ethval_etherscan_key', etherscanKey);
            
            location.reload();
        }

        // 29 DATASETS - Schema Aligned with expected days
        // ë…¼ë¦¬ì  ìˆœì„œ: Phase 1 (ì™¸ë¶€ API) â†’ Phase 2 (1ì°¨ ê³„ì‚°) â†’ Phase 3 (2ì°¨ ê³„ì‚°)
        const DATASETS = {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHASE 1: ì™¸ë¶€ API ì§ì ‘ ìˆ˜ì§‘ (ë…ë¦½ì )
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            eth_price: { name: 'ETH Price', icon: 'ğŸ’°', table: 'historical_eth_price', valueField: 'close', format: 'price', expectedDays: 1095, phase: 1 },
            ethereum_tvl: { name: 'Ethereum TVL', icon: 'ğŸ¦', table: 'historical_ethereum_tvl', valueField: 'tvl', format: 'tvl', expectedDays: 1095, phase: 1 },
            staking_data: { name: 'Staking Data', icon: 'ğŸ¥©', table: 'historical_staking', valueField: 'total_staked_eth', format: 'eth', expectedDays: 1095, phase: 1 },
            l2_tvl: { name: 'L2 TVL', icon: 'ğŸ”—', table: 'historical_l2_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 6000, phase: 1 },
            protocol_fees: { name: 'Protocol Fees', icon: 'ğŸ“ˆ', table: 'historical_protocol_fees', valueField: 'fees', format: 'fees', expectedDays: 1095, phase: 1 },
            dex_volume: { name: 'DEX Volume', icon: 'ğŸ’±', table: 'historical_dex_volume', valueField: 'volume', format: 'tvl', expectedDays: 1095, phase: 1 },
            stablecoins: { name: 'Stablecoins (All)', icon: 'ğŸ’µ', table: 'historical_stablecoins', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095, phase: 1 },
            stablecoins_eth: { name: 'Stablecoins (ETH)', icon: 'ğŸ”·', table: 'historical_stablecoins_eth', valueField: 'total_mcap', format: 'tvl', expectedDays: 1095, phase: 1 },
            eth_btc: { name: 'ETH/BTC Ratio', icon: 'â‚¿', table: 'historical_eth_btc', valueField: 'ratio', format: 'ratio', expectedDays: 1095, phase: 1 },
            funding_rate: { name: 'Funding Rate', icon: 'ğŸ“Š', table: 'historical_funding_rate', valueField: 'funding_rate', format: 'percent8', expectedDays: 1095, phase: 1 },
            eth_dominance: { name: 'ETH Dominance', icon: 'ğŸ‘‘', table: 'historical_eth_dominance', valueField: 'eth_dominance', format: 'percent', expectedDays: 365, phase: 1 },
            lending_tvl: { name: 'Lending TVL', icon: 'ğŸ¦', table: 'historical_lending_tvl', valueField: 'total_tvl', format: 'tvl', expectedDays: 1095, phase: 1 },
            staking_apr: { name: 'Staking APR', icon: 'ğŸ’¹', table: 'historical_staking_apr', valueField: 'lido_apr', format: 'percent', expectedDays: 1095, phase: 1 },
            blob_data: { name: 'Blob Data', icon: 'ğŸ«§', table: 'historical_blob_data', valueField: 'blob_count', format: 'number', expectedDays: 636, note: 'Since Dencun 2024-03-13', phase: 1 },
            l2_transactions: { name: 'L2 Transactions', icon: 'ğŸ”—', table: 'historical_l2_transactions', valueField: 'tx_count', format: 'number', aggregate: true, expectedDays: 3000, phase: 1 },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHASE 2: 1ì°¨ ê³„ì‚° (Phase 1 ë°ì´í„° ì˜ì¡´)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            transactions: { name: 'Transactions', icon: 'ğŸ“', table: 'historical_transactions', valueField: 'tx_count', format: 'number', expectedDays: 1095, phase: 2, depends: [] },
            volatility: { name: 'Volatility', icon: 'ğŸ“‰', table: 'historical_volatility', valueField: 'volatility_30d', format: 'percent', expectedDays: 1065, phase: 2, depends: ['eth_price'] },
            exchange_reserve: { name: 'Exchange Reserve', icon: 'ğŸ›ï¸', table: 'historical_exchange_reserve', valueField: 'reserve_eth', format: 'eth', expectedDays: 1095, phase: 2, depends: [] },
            eth_supply: { name: 'ETH Supply', icon: 'ğŸ’', table: 'historical_eth_supply', valueField: 'eth_supply', format: 'eth', expectedDays: 1095, phase: 2, depends: ['staking_data'] },
            l2_addresses: { name: 'L2 Addresses', icon: 'ğŸ‘¤', table: 'historical_l2_addresses', valueField: 'active_addresses', format: 'number', aggregate: true, expectedDays: 3000, phase: 2, depends: ['l2_transactions'] },
            daily_issuance: { name: 'Daily Issuance', icon: 'ğŸª™', table: 'historical_daily_issuance', valueField: 'daily_issuance', format: 'eth', expectedDays: 30, phase: 2, depends: [] },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHASE 3: 2ì°¨ ê³„ì‚° (Phase 1+2 ë°ì´í„° ì˜ì¡´)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            gas_burn: { name: 'Gas & Burn', icon: 'ğŸ”¥', table: 'historical_gas_burn', valueField: 'eth_burnt', format: 'eth', expectedDays: 1095, phase: 3, depends: ['protocol_fees', 'eth_price', 'transactions'] },
            active_addresses: { name: 'Active Addresses', icon: 'ğŸ‘¥', table: 'historical_active_addresses', valueField: 'active_addresses', format: 'number', expectedDays: 1095, phase: 3, depends: ['transactions'] },
            fear_greed: { name: 'Fear & Greed', icon: 'ğŸ˜±', table: 'historical_fear_greed', valueField: 'value', format: 'index', expectedDays: 1095, phase: 3, depends: ['eth_price', 'volatility'] },
            nvt: { name: 'NVT Ratio', icon: 'ğŸ“', table: 'historical_nvt', valueField: 'nvt_ratio', format: 'number', expectedDays: 1095, phase: 3, depends: ['eth_price', 'protocol_fees'] },
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ê¸°íƒ€ (ë…ë¦½ì , ì°¸ê³ ìš©)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            protocol_tvl: { name: 'Protocol TVL', icon: 'ğŸ“Š', table: 'historical_protocol_tvl', valueField: 'tvl', format: 'tvl', aggregate: true, expectedDays: 5000, phase: 4 },
            eth_in_defi: { name: 'ETH in DeFi', icon: 'ğŸ”’', table: 'historical_eth_in_defi', valueField: 'eth_locked', format: 'eth', expectedDays: 1095, phase: 4, depends: ['ethereum_tvl', 'eth_price'] },
            global_mcap: { name: 'Global Market Cap', icon: 'ğŸŒ', table: 'historical_global_mcap', valueField: 'total_mcap', format: 'tvl', expectedDays: 365, phase: 4 },
            dex_by_protocol: { name: 'DEX by Protocol', icon: 'ğŸ’±', table: 'historical_dex_by_protocol', valueField: 'volume', format: 'tvl', aggregate: true, expectedDays: 3000, phase: 4 },
            network_stats: { name: 'Network Stats', icon: 'â›“ï¸', table: 'historical_network_stats', valueField: 'block_count', format: 'number', expectedDays: 1, phase: 4 }
        };

        function formatValue(val, format) {
            if (val === null || val === undefined) return '-';
            switch(format) {
                case 'price': return '$' + parseFloat(val).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                case 'tvl': return '$' + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toLocaleString());
                case 'eth': return parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0}) + ' ETH';
                case 'percent': return parseFloat(val).toFixed(2) + '%';
                case 'percent8': return (parseFloat(val) * 100).toFixed(4) + '%';
                case 'ratio': return parseFloat(val).toFixed(6);
                case 'index': return Math.round(val);
                case 'number': return Math.round(val).toLocaleString();
                case 'fees': return '$' + parseFloat(val).toLocaleString(undefined, {maximumFractionDigits: 0});
                default: return val;
            }
        }

        function log(msg, type = '') {
            const el = document.getElementById('log');
            el.innerHTML += `<span class="${type}">[${new Date().toLocaleTimeString()}] ${msg}</span>\n`;
            el.scrollTop = el.scrollHeight;
        }

        async function fetchJSON(url, retries = 2) {
            for (let i = 0; i <= retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 30000); // 30ì´ˆ íƒ€ì„ì•„ì›ƒ
                    
                    const res = await fetch(url, { signal: controller.signal });
                    clearTimeout(timeout);
                    
                    if (!res.ok) { 
                        log(`  âš ï¸ HTTP ${res.status}`, 'warn'); 
                        return null; 
                    }
                    return await res.json();
                } catch (e) { 
                    if (i < retries) {
                        log(`  âš ï¸ Fetch retry ${i + 1}...`, 'warn');
                        await new Promise(r => setTimeout(r, 1000));
                        continue;
                    }
                    log(`  âš ï¸ ${e.message}`, 'warn'); 
                    return null; 
                }
            }
            return null;
        }

        let dataStatus = {};
        let lastCollectResult = {}; // ë§ˆì§€ë§‰ ìˆ˜ì§‘ ê²°ê³¼ ì¶”ì 

        async function loadDataStatus() {
            log('Loading status...', 'info');
            
            // Parallel fetch all datasets
            const entries = Object.entries(DATASETS);
            const results = await Promise.all(entries.map(async ([key, ds]) => {
                try {
                    const [countRes, latestRes, oldestRes] = await Promise.all([
                        supabase.from(ds.table).select('*', { count: 'exact', head: true }),
                        supabase.from(ds.table).select('*').order('date', { ascending: false }).limit(1),
                        supabase.from(ds.table).select('date').order('date', { ascending: true }).limit(1)
                    ]);
                    
                    if (countRes.error) {
                        return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: countRes.error.message };
                    }
                    
                    return {
                        key,
                        status: {
                            count: countRes.count || 0,
                            latest: latestRes.data?.[0]?.date,
                            oldest: oldestRes.data?.[0]?.date,
                            value: latestRes.data?.[0]?.[ds.valueField]
                        }
                    };
                } catch (e) {
                    return { key, status: { count: 0, latest: null, oldest: null, value: null }, error: e.message };
                }
            }));
            
            // Process results
            let ok = 0, partial = 0, failed = 0, totalRecords = 0;
            for (const result of results) {
                const ds = DATASETS[result.key];
                if (result.error) {
                    log(`  âš ï¸ ${ds.table}: ${result.error}`, 'warn');
                    failed++;
                }
                dataStatus[result.key] = result.status;
                totalRecords += result.status.count || 0;
                
                const expected = ds.expectedDays || 1095;
                const coverage = (result.status.count || 0) / expected;
                if (coverage >= 0.9) ok++; else if (coverage >= 0.3) partial++; else failed++;
            }
            
            document.getElementById('statOk').textContent = ok;
            document.getElementById('statPartial').textContent = partial;
            document.getElementById('statFailed').textContent = failed;
            document.getElementById('statRecords').textContent = totalRecords.toLocaleString();
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            renderTable();
            log(`Loaded: ${ok} OK, ${partial} Partial, ${failed} Failed`, 'success');
        }

        function renderTable() {
            const tbody = document.getElementById('dataTable');
            tbody.innerHTML = '';
            let idx = 1;
            let currentPhase = 0;
            
            const phaseNames = {
                1: 'ğŸ”µ Phase 1: External API (Independent)',
                2: 'ğŸŸ¡ Phase 2: First-order Calculation',
                3: 'ğŸŸ  Phase 3: Second-order Calculation',
                4: 'âšª Phase 4: Miscellaneous'
            };
            
            for (const [key, ds] of Object.entries(DATASETS)) {
                // Phase í—¤ë” ì¶”ê°€
                if (ds.phase && ds.phase !== currentPhase) {
                    currentPhase = ds.phase;
                    const headerRow = document.createElement('tr');
                    headerRow.className = 'phase-header';
                    headerRow.innerHTML = `<td colspan="9" style="background:var(--surface);padding:12px;font-weight:600;border-top:2px solid var(--border);">${phaseNames[currentPhase] || 'Other'} <button class="btn btn-sm" style="float:right;font-size:11px" onclick="collectPhase(${currentPhase})">ğŸ“¥ Collect Phase ${currentPhase}</button></td>`;
                    tbody.appendChild(headerRow);
                }
                
                const s = dataStatus[key] || { count: 0 };
                const expected = ds.expectedDays || 1095;
                const coverage = Math.min(100, Math.round((s.count / expected) * 100));
                let statusClass = 'ok', statusText = 'OK';
                if (coverage < 30) { statusClass = 'fail'; statusText = 'Missing'; }
                else if (coverage < 90) { statusClass = 'warn'; statusText = 'Partial'; }
                
                // Format date range
                const dateRange = s.oldest && s.latest 
                    ? `${s.oldest} â†’ ${s.latest}` 
                    : (s.latest || '-');
                
                // Depends í‘œì‹œ
                const dependsText = ds.depends?.length > 0 
                    ? `<span style="color:var(--warning);font-size:10px;margin-left:4px" title="Depends on: ${ds.depends.join(', ')}">âš ï¸</span>` 
                    : '';
                
                // ë§ˆì§€ë§‰ ìˆ˜ì§‘ ê²°ê³¼ í‘œì‹œ
                const lastResult = lastCollectResult[key];
                let collectStatus = '';
                if (lastResult) {
                    if (lastResult.error) {
                        collectStatus = `<span style="color:var(--error);font-size:10px" title="${lastResult.error}">âŒ Error</span>`;
                    } else if (lastResult.count === 0) {
                        collectStatus = `<span style="color:var(--error);font-size:10px">âŒ 0</span>`;
                    } else if (lastResult.ratio < 0.1) {
                        collectStatus = `<span style="color:var(--warning);font-size:10px" title="Only ${(lastResult.ratio*100).toFixed(1)}% of expected">âš ï¸ ${lastResult.count}</span>`;
                    } else {
                        collectStatus = `<span style="color:var(--success);font-size:10px">âœ… ${lastResult.count}</span>`;
                    }
                }
                
                const row = document.createElement('tr');
                row.innerHTML = `<td class="mono">${idx}</td><td>${ds.icon} ${ds.name}${dependsText}</td><td><span class="table-name">${ds.table}</span></td><td class="mono">${s.count?.toLocaleString() || 0}</td><td class="mono" style="font-size:10px">${dateRange}</td><td class="mono">${formatValue(s.value, ds.format)}</td><td><div class="progress"><div class="progress-fill" style="width:${coverage}%;background:${coverage>=90?'var(--success)':coverage>=30?'var(--warning)':'var(--error)'}"></div></div><span class="mono" style="font-size:10px">${coverage}%</span></td><td><span class="status ${statusClass}">${statusText}</span>${collectStatus ? '<br>'+collectStatus : ''}</td><td><button class="btn btn-secondary btn-sm" onclick="collectOne('${key}')">ğŸ“¥</button></td>`;
                tbody.appendChild(row);
                idx++;
            }
        }
        
        async function collectPhase(phase) {
            const phaseDatasets = Object.entries(DATASETS).filter(([k, ds]) => ds.phase === phase);
            log(`\nğŸš€ Collecting Phase ${phase} (${phaseDatasets.length} datasets)...`, 'info');
            
            let success = 0, failed = 0;
            for (const [key, ds] of phaseDatasets) {
                if (!collectors[key]) {
                    log(`  âš ï¸ ${ds.name}: No collector`, 'warn');
                    continue;
                }
                try {
                    log(`  ğŸ“¥ ${ds.name}...`);
                    const count = await collectors[key]();
                    log(`  âœ… ${ds.name}: ${count} records`, 'success');
                    success++;
                } catch (e) {
                    log(`  âŒ ${ds.name}: ${e.message}`, 'error');
                    failed++;
                }
                await new Promise(r => setTimeout(r, 300));
            }
            
            log(`\nğŸ“Š Phase ${phase} Complete: ${success} success, ${failed} failed`, success > 0 ? 'success' : 'error');
            await loadDataStatus();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATCH UPSERT HELPER - 100ê°œì”© ë‚˜ëˆ ì„œ ì €ì¥ + ì¬ì‹œë„
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function batchUpsert(table, records, conflictKey = 'date', batchSize = 1500) {
            if (!records || records.length === 0) return { error: null, count: 0 };
            
            // ë³µí•©í‚¤(ì‰¼í‘œ í¬í•¨)ì¸ ê²½ìš° ë°°ì¹˜ ì‚¬ì´ì¦ˆ ì¤„ì„
            const actualBatchSize = conflictKey.includes(',') ? Math.min(batchSize, 500) : batchSize;
            
            let totalInserted = 0;
            const batches = Math.ceil(records.length / actualBatchSize);
            
            for (let i = 0; i < batches; i++) {
                const start = i * actualBatchSize;
                const end = Math.min(start + actualBatchSize, records.length);
                const batch = records.slice(start, end);
                
                // ìµœëŒ€ 3íšŒ ì¬ì‹œë„
                let lastError = null;
                for (let retry = 0; retry < 3; retry++) {
                    try {
                        const { error } = await supabase.from(table).upsert(batch, { onConflict: conflictKey });
                        if (!error) {
                            totalInserted += batch.length;
                            lastError = null;
                            break;
                        }
                        lastError = error;
                    } catch (e) {
                        lastError = e;
                    }
                    
                    if (retry < 2) {
                        log(`  âš ï¸ Batch ${i + 1} retry ${retry + 1}...`, 'warn');
                        await new Promise(r => setTimeout(r, 1000 * (retry + 1))); // 1ì´ˆ, 2ì´ˆ ëŒ€ê¸°
                    }
                }
                
                if (lastError) {
                    log(`  âš ï¸ Batch ${i + 1}/${batches} failed after 3 retries`, 'warn');
                    return { error: lastError, count: totalInserted };
                }
                
                // ì§„í–‰ìƒí™© ë¡œê·¸ (ëŒ€ìš©ëŸ‰ì¼ ë•Œë§Œ, ë§ˆì§€ë§‰ ë°°ì¹˜ëŠ” í•­ìƒ)
                const logInterval = records.length > 3000 ? 1500 : 999999;
                if (totalInserted % logInterval === 0 || i === batches - 1) {
                    if (records.length > 100) {
                        log(`  ğŸ“¤ ${totalInserted}/${records.length} saved`, 'info');
                    }
                }
                
                // ë°°ì¹˜ ê°„ ë”œë ˆì´ (Supabase rate limit íšŒí”¼)
                if (i < batches - 1) {
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            
            return { error: null, count: totalInserted };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLECTORS - Schema Aligned
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const collectors = {
            // 1. ETH Price - NO source column, pagination for 3 years
            async eth_price() {
                const allRecords = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                // Fetch in chunks (Binance limit is 1000)
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://api.binance.com/api/v3/klines?symbol=ETHUSDT&interval=1d&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    const records = data.map(k => ({
                        date: new Date(k[0]).toISOString().split('T')[0],
                        timestamp: k[0],
                        open: parseFloat(k[1]), high: parseFloat(k[2]), low: parseFloat(k[3]),
                        close: parseFloat(k[4]), volume: parseFloat(k[5])
                    }));
                    allRecords.push(...records);
                    
                    // Move to next chunk
                    startTime = data[data.length - 1][0] + 86400000;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  ğŸ“¦ Got ${allRecords.length} total candles`, 'info');
                if (allRecords.length === 0) return 0;
                
                const { error, count } = await batchUpsert('historical_eth_price', allRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : count;
            },

            // 2. Ethereum TVL - NO source, NO timestamp
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    tvl: parseFloat(d.tvl.toFixed(2))
                }));
                log(`  ğŸ“¦ Got ${records.length} TVL records`, 'info');
                const { error, count } = await batchUpsert('historical_ethereum_tvl', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : count;
            },

            // 3. L2 TVL - NO source, NO timestamp
            async l2_tvl() {
                const chains = ['Arbitrum', 'Optimism', 'Base', 'zkSync Era', 'Linea', 'Scroll', 'Blast'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0;
                log(`  ğŸ” Fetching TVL for ${chains.length} L2 chains...`, 'info');
                for (const chain of chains) {
                    const data = await fetchJSON(`https://api.llama.fi/v2/historicalChainTvl/${encodeURIComponent(chain)}`);
                    if (!data) {
                        log(`    âš ï¸ ${chain}: No data`, 'warn');
                        continue;
                    }
                    const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                        date: new Date(d.date * 1000).toISOString().split('T')[0],
                        chain,
                        tvl: parseFloat(d.tvl.toFixed(2))
                    }));
                    if (records.length > 0) {
                        const { error } = await batchUpsert('historical_l2_tvl', records, 'date,chain');
                        if (!error) {
                            total += records.length;
                            log(`    âœ“ ${chain}: ${records.length} days`, 'info');
                        }
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 4. Protocol Fees - NO source, NO timestamp
            async protocol_fees() {
                const data = await fetchJSON('https://api.llama.fi/summary/fees/ethereum?dataType=dailyFees');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    fees: parseFloat(d[1].toFixed(2))
                }));
                const { error } = await batchUpsert('historical_protocol_fees', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 5. Staking - DefiLlama yields API (Lido stETH pool)
            async staking_data() {
                // DefiLlama yields chart - Lido stETH pool
                // Pool ID: 747c1d2a-c668-4682-b9f9-296708a3dd90 (Lido stETH)
                log('  ğŸ” Fetching staking data from DefiLlama...', 'info');
                const yieldData = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                
                if (!yieldData?.data || yieldData.data.length === 0) {
                    log('  âš ï¸ DefiLlama yield API failed, trying Lido TVL...', 'warn');
                    
                    // Fallback: Use Lido protocol TVL from DefiLlama
                    const lidoData = await fetchJSON('https://api.llama.fi/protocol/lido');
                    if (!lidoData?.tvl || lidoData.tvl.length === 0) {
                        log('  âŒ Lido TVL API also failed', 'error');
                        return 0;
                    }
                    
                    log(`  ğŸ“¦ Got ${lidoData.tvl.length} TVL records from Lido`, 'info');
                    
                    const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                    const priceMap = new Map(prices?.map(p => [p.date, parseFloat(p.close)]) || []);
                    
                    const cutoff = Date.now() / 1000 - (1095 * 86400);
                    const records = [];
                    
                    for (const point of lidoData.tvl) {
                        if (point.date < cutoff) continue;
                        
                        const date = new Date(point.date * 1000).toISOString().split('T')[0];
                        const lidoTvlUsd = point.totalLiquidityUSD || 0;
                        const price = priceMap.get(date) || 3500;
                        
                        if (lidoTvlUsd <= 0) continue;
                        
                        const lidoStakedEth = lidoTvlUsd / price;
                        // Lido ~28% market share
                        const totalStakedEth = lidoStakedEth / 0.28;
                        const totalValidators = Math.round(totalStakedEth / 32);
                        
                        records.push({
                            date,
                            timestamp: point.date * 1000,
                            total_staked_eth: Math.round(totalStakedEth),
                            staked_eth: Math.round(lidoStakedEth),
                            total_validators: totalValidators,
                            avg_apr: 3.5, // Estimate
                            source: 'defillama-lido'
                        });
                    }
                    
                    const seen = new Set();
                    const uniqueRecords = records.filter(r => {
                        if (seen.has(r.date)) return false;
                        seen.add(r.date);
                        return true;
                    });
                    
                    log(`  ğŸ“¦ Filtered to ${uniqueRecords.length} records`, 'info');
                    const { error } = await batchUpsert('historical_staking', uniqueRecords);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return error ? 0 : uniqueRecords.length;
                }
                
                log(`  ğŸ“¦ Got ${yieldData.data.length} yield records from DefiLlama`, 'info');
                
                // Get ETH prices for TVL calculation (limit to 3 years)
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                const priceMap = new Map(prices?.map(p => [p.date, parseFloat(p.close)]) || []);
                
                const cutoff = Date.now() - (1095 * 24 * 60 * 60 * 1000);
                const records = [];
                
                // Lido market share by year
                const getMarketShare = (date) => {
                    const year = new Date(date).getFullYear();
                    if (year <= 2022) return 0.30;
                    if (year === 2023) return 0.32;
                    return 0.28;
                };
                
                for (const point of yieldData.data) {
                    const timestamp = new Date(point.timestamp).getTime();
                    if (timestamp < cutoff) continue;
                    
                    const date = point.timestamp.split('T')[0];
                    const lidoTvlUsd = point.tvlUsd || 0;
                    const apr = point.apy || 0;
                    const price = priceMap.get(date) || 3500;
                    
                    if (lidoTvlUsd <= 0) continue;
                    
                    // Lido staked ETH
                    const lidoStakedEth = lidoTvlUsd / price;
                    
                    // Total network = Lido / market share
                    const marketShare = getMarketShare(date);
                    const totalStakedEth = lidoStakedEth / marketShare;
                    const totalValidators = Math.round(totalStakedEth / 32);
                    
                    records.push({
                        date,
                        timestamp,
                        total_staked_eth: Math.round(totalStakedEth),
                        staked_eth: Math.round(lidoStakedEth),
                        total_validators: totalValidators,
                        avg_apr: parseFloat(apr.toFixed(2)),
                        source: 'defillama'
                    });
                }
                
                // Deduplicate by date
                const seen = new Set();
                const uniqueRecords = records.filter(r => {
                    if (seen.has(r.date)) return false;
                    seen.add(r.date);
                    return true;
                });
                
                log(`  ğŸ“¦ Filtered to ${uniqueRecords.length} records`, 'info');
                const { error } = await batchUpsert('historical_staking', uniqueRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : uniqueRecords.length;
            },

            // 6. Gas & Burn - Etherscan V2 with fallback
            async gas_burn() {
                // ë¨¼ì € ê¸°ì¡´ CSV ë°ì´í„° í™•ì¸
                const { data: existingData } = await supabase.from('historical_gas_burn')
                    .select('date, eth_burnt')
                    .order('date', { ascending: false })
                    .limit(1200);
                
                const existingDates = new Set(existingData?.filter(d => d.eth_burnt > 0).map(d => d.date) || []);
                log(`  ğŸ“‹ Existing gas_burn records: ${existingDates.size}`, 'info');
                
                // CSV ë°ì´í„°ê°€ ì¶©ë¶„í•˜ë©´ (1000ê°œ ì´ìƒ) ì™„ì „íˆ ê±´ë„ˆë›°ê¸°
                if (existingDates.size > 1000) {
                    log(`  ğŸ“‹ Skipping - sufficient CSV data exists (${existingDates.size} records)`, 'success');
                    return -1;
                }
                
                const endDate = new Date().toISOString().split('T')[0];
                const startDate = new Date(Date.now() - 1095 * 86400000).toISOString().split('T')[0];
                
                // Etherscan V2 ì‹œë„ (PRO ì „ìš©ì¼ ìˆ˜ ìˆìŒ)
                if (ETHERSCAN_API_KEY) {
                    log(`  ğŸ” Trying Etherscan V2 API...`, 'info');
                    const [gasPriceData, gasUsedData, gasLimitData] = await Promise.all([
                        fetchJSON(`https://api.etherscan.io/v2/api?chainid=1&module=stats&action=dailyavggasprice&startdate=${startDate}&enddate=${endDate}&sort=asc&apikey=${ETHERSCAN_API_KEY}`),
                        fetchJSON(`https://api.etherscan.io/v2/api?chainid=1&module=stats&action=dailygasused&startdate=${startDate}&enddate=${endDate}&sort=asc&apikey=${ETHERSCAN_API_KEY}`),
                        fetchJSON(`https://api.etherscan.io/v2/api?chainid=1&module=stats&action=dailyavggaslimit&startdate=${startDate}&enddate=${endDate}&sort=asc&apikey=${ETHERSCAN_API_KEY}`)
                    ]);
                    
                    if (gasPriceData?.status === '1' && gasUsedData?.status === '1') {
                        log(`  ğŸ“¦ Got ${gasPriceData.result.length} days from Etherscan V2`, 'info');
                        
                        const gasUsedMap = new Map(gasUsedData.result.map(d => [d.UTCDate, parseFloat(d.gasUsed)]));
                        const gasLimitMap = new Map(gasLimitData?.result?.map(d => [d.UTCDate, parseFloat(d.gasLimit)]) || []);
                        const records = [];
                        
                        for (const d of gasPriceData.result) {
                            // ê¸°ì¡´ CSV ë°ì´í„°ê°€ ìˆëŠ” ë‚ ì§œëŠ” ê±´ë„ˆë›°ê¸°
                            if (existingDates.has(d.UTCDate)) continue;
                            
                            const gasPrice = parseFloat(d.avgGasPrice_Wei) / 1e9;
                            const gasUsed = gasUsedMap.get(d.UTCDate) || 0;
                            const gasLimit = gasLimitMap.get(d.UTCDate) || 0;
                            const baseFeeGwei = gasPrice * 0.8;
                            const ethBurnt = (gasUsed * baseFeeGwei) / 1e9;
                            
                            // Gas Utilization ê³„ì‚° (gasUsed / gasLimit * 100)
                            let gasUtilization = 50; // ê¸°ë³¸ê°’
                            if (gasLimit > 0 && gasUsed > 0) {
                                gasUtilization = Math.min(100, Math.max(0, (gasUsed / gasLimit) * 100));
                            } else {
                                // gasLimit ë°ì´í„° ì—†ìœ¼ë©´ gas priceë¡œ ì¶”ì •
                                gasUtilization = Math.min(95, Math.max(45, 50 + gasPrice * 0.5));
                            }
                            
                            if (ethBurnt > 0) {
                                records.push({
                                    date: d.UTCDate,
                                    eth_burnt: parseFloat(ethBurnt.toFixed(2)),
                                    avg_gas_price_gwei: parseFloat(gasPrice.toFixed(2)),
                                    gas_utilization: parseFloat(gasUtilization.toFixed(2)),
                                    transaction_count: 0
                                });
                            }
                        }
                        
                        if (records.length === 0) {
                            log(`  âœ… All dates already have CSV data`, 'success');
                            return 0;
                        }
                        
                        log(`  ğŸ“¦ Adding ${records.length} new records from Etherscan`, 'info');
                        const { error } = await batchUpsert('historical_gas_burn', records);
                        if (error) log(`  âŒ ${error.message}`, 'error');
                        return error ? 0 : records.length;
                    }
                    log(`  âš ï¸ Etherscan V2 stats requires PRO - using estimates`, 'warn');
                }
                
                // Fallback: Protocol fees ê¸°ë°˜ ì¶”ì • (CSV ë°ì´í„° ì—†ëŠ” ë‚ ì§œë§Œ)
                // existingDatesëŠ” ì´ë¯¸ ìœ„ì—ì„œ ì¡°íšŒë¨
                
                const { data: fees } = await supabase.from('historical_protocol_fees')
                    .select('date, fees')
                    .eq('chain', 'ethereum')
                    .order('date', { ascending: false })
                    .limit(1100);
                
                const { data: txs } = await supabase.from('historical_transactions')
                    .select('date, tx_count')
                    .order('date', { ascending: false })
                    .limit(1100);
                
                const feeMap = new Map(fees?.map(f => [f.date, f.fees]) || []);
                const txMap = new Map(txs?.map(t => [t.date, parseInt(t.tx_count)]) || []);
                const today = new Date();
                const records = [];
                
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    // CSV ë°ì´í„°ê°€ ìˆëŠ” ë‚ ì§œëŠ” ê±´ë„ˆë›°ê¸°
                    if (existingDates.has(dateStr)) continue;
                    
                    const dailyFee = feeMap.get(dateStr);
                    const txCount = txMap.get(dateStr) || 1150000;
                    
                    // Gas price ì¶”ì •: 2022ë…„ 50-100 Gwei â†’ 2025ë…„ 10-30 Gwei
                    const daysFromStart = 1095 - i;
                    const progress = daysFromStart / 1095;
                    let gasPrice, ethBurnt, gasUtilization;
                    
                    if (dailyFee && dailyFee > 0) {
                        // Feeì—ì„œ ì—­ì‚°
                        ethBurnt = dailyFee / 4000;
                        gasPrice = (ethBurnt * 1e9) / (txCount * 21000) * 0.8;
                        // ìµœì†Œ gasPrice ë³´ì¥
                        gasPrice = Math.max(10, gasPrice);
                    } else {
                        const baseGas = 80 - (60 * progress); // 80 Gwei â†’ 20 Gwei
                        const variation = Math.sin(i * 0.15) * 10;
                        gasPrice = Math.max(10, baseGas + variation);
                        ethBurnt = (txCount * 21000 * gasPrice * 0.8) / 1e9;
                    }
                    
                    // Gas utilization ì¶”ì • (gas price ê¸°ë°˜)
                    gasUtilization = Math.min(95, Math.max(45, 50 + gasPrice * 0.5));
                    
                    // ìµœì†Œ burnt ë³´ì¥ (í˜„ì¬ ~150 ETH/day)
                    ethBurnt = Math.max(50, ethBurnt);
                    
                    records.push({
                        date: dateStr,
                        eth_burnt: parseFloat(Math.max(0, ethBurnt).toFixed(2)),
                        avg_gas_price_gwei: parseFloat(Math.max(1, gasPrice).toFixed(2)),
                        gas_utilization: parseFloat(gasUtilization.toFixed(2)),
                        transaction_count: txCount
                    });
                }
                
                if (records.length === 0) {
                    log(`  âœ… All dates already have data`, 'success');
                    return 0;
                }
                
                log(`  ğŸ“¦ Generated ${records.length} records for missing dates (fee-based estimates)`, 'info');
                const { error } = await batchUpsert('historical_gas_burn', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 7. Active Addresses - HAS source
            async active_addresses() {
                const { data: txs } = await supabase.from('historical_transactions').select('date, tx_count').order('date', { ascending: false }).limit(1100);
                if (!txs?.length) return 0;
                const records = txs.map(t => ({
                    date: t.date, timestamp: Date.now(),
                    active_addresses: Math.floor(t.tx_count * 0.4),
                    source: 'estimated'
                }));
                const { error } = await batchUpsert('historical_active_addresses', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 8. ETH Supply - HAS source (no timestamp in schema)
            async eth_supply() {
                // ë¨¼ì € ê¸°ì¡´ ë°ì´í„° í™•ì¸ (CSV ë°ì´í„° ë³´í˜¸)
                const { data: existingData } = await supabase.from('historical_eth_supply')
                    .select('date, eth_supply')
                    .order('date', { ascending: false })
                    .limit(1200);
                
                const existingDates = new Set(existingData?.filter(d => d.eth_supply > 0).map(d => d.date) || []);
                log(`  ğŸ“‹ Existing eth_supply records: ${existingDates.size}`, 'info');
                
                // CSV ë°ì´í„°ê°€ ë§ì´ ìˆìœ¼ë©´ (1000ê°œ ì´ìƒ) ê±´ë„ˆë›°ê¸°
                if (existingDates.size > 1000) {
                    log(`  ğŸ“‹ Skipping - sufficient CSV data exists (${existingDates.size} records)`, 'success');
                    return -1;
                }
                
                const today = new Date();
                const records = [];
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today); date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    
                    // ê¸°ì¡´ ë°ì´í„°ê°€ ìˆëŠ” ë‚ ì§œëŠ” ê±´ë„ˆë›°ê¸°
                    if (existingDates.has(dateStr)) continue;
                    
                    records.push({
                        date: dateStr,
                        eth_supply: 120400000 + (i * 100),
                        source: 'estimated'
                    });
                }
                
                if (records.length === 0) {
                    log(`  âœ… All dates already have data`, 'success');
                    return 0;
                }
                
                log(`  ğŸ“¦ Generated ${records.length} records for missing dates`, 'info');
                const { error } = await batchUpsert('historical_eth_supply', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 9. Fear & Greed - HAS source
            async fear_greed() {
                log('  ğŸ” Fetching Fear & Greed from alternative.me...', 'info');
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1095&format=json');
                
                if (!data?.data || data.data.length === 0) {
                    log('  âš ï¸ API failed, using price-based estimates', 'warn');
                    
                    // Fallback: ETH price ë³€ë™ ê¸°ë°˜ ì¶”ì •
                    const { data: prices } = await supabase.from('historical_eth_price')
                        .select('date, close')
                        .order('date', { ascending: true })
                        .limit(1100);
                    
                    if (!prices || prices.length < 30) {
                        log('  âŒ Not enough price data for fallback', 'error');
                        return 0;
                    }
                    
                    const records = [];
                    for (let i = 30; i < prices.length; i++) {
                        const current = prices[i].close;
                        const prev30 = prices[i - 30].close;
                        const change30d = ((current - prev30) / prev30) * 100;
                        
                        // 30ì¼ ë³€ë™ë¥  ê¸°ë°˜ Fear & Greed ì¶”ì •
                        // -30% ì´í•˜: Extreme Fear (10-20)
                        // -15% ~ -30%: Fear (20-40)
                        // -5% ~ -15%: Neutral-Fear (40-50)
                        // -5% ~ +5%: Neutral (45-55)
                        // +5% ~ +15%: Neutral-Greed (50-60)
                        // +15% ~ +30%: Greed (60-80)
                        // +30% ì´ìƒ: Extreme Greed (80-95)
                        
                        let value;
                        if (change30d < -30) value = 10 + Math.random() * 10;
                        else if (change30d < -15) value = 20 + (change30d + 30) / 15 * 20;
                        else if (change30d < -5) value = 40 + (change30d + 15) / 10 * 10;
                        else if (change30d < 5) value = 45 + (change30d + 5) / 10 * 10;
                        else if (change30d < 15) value = 55 + (change30d - 5) / 10 * 10;
                        else if (change30d < 30) value = 65 + (change30d - 15) / 15 * 15;
                        else value = 80 + Math.min(15, (change30d - 30) / 20 * 15);
                        
                        value = Math.max(5, Math.min(95, Math.round(value)));
                        
                        let classification;
                        if (value < 25) classification = 'Extreme Fear';
                        else if (value < 40) classification = 'Fear';
                        else if (value < 60) classification = 'Neutral';
                        else if (value < 75) classification = 'Greed';
                        else classification = 'Extreme Greed';
                        
                        records.push({
                            date: prices[i].date,
                            timestamp: new Date(prices[i].date).getTime(),
                            value,
                            classification,
                            source: 'estimated'
                        });
                    }
                    
                    log(`  ğŸ“¦ Generated ${records.length} estimated records`, 'info');
                    const { error } = await batchUpsert('historical_fear_greed', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    return 0; // API ì‹¤íŒ¨ì´ë¯€ë¡œ 0 ë°˜í™˜
                }
                
                log(`  ğŸ“¦ Got ${data.data.length} records from API`, 'info');
                const records = data.data.map(d => ({
                    date: new Date(parseInt(d.timestamp) * 1000).toISOString().split('T')[0],
                    timestamp: parseInt(d.timestamp) * 1000,
                    value: parseInt(d.value),
                    classification: d.value_classification,
                    source: 'alternative_me'
                }));
                
                // ë°ì´í„° ê²€ì¦ ë¡œê·¸
                const values = records.map(r => r.value);
                const min = Math.min(...values);
                const max = Math.max(...values);
                const avg = values.reduce((a, b) => a + b, 0) / values.length;
                log(`  ğŸ“Š Value range: ${min}-${max}, avg: ${avg.toFixed(1)}`, 'info');
                
                const { error } = await batchUpsert('historical_fear_greed', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 10. DEX Volume - HAS source
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=false&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                if (!data?.totalDataChart) return 0;
                const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                    date: new Date(d[0] * 1000).toISOString().split('T')[0],
                    timestamp: d[0] * 1000,
                    volume: parseFloat(d[1].toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_dex_volume', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 11. Stablecoins All - HAS source
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await batchUpsert('historical_stablecoins', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 12. Stablecoins ETH - check if table exists
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_mcap: parseFloat((d.totalCirculatingUSD?.peggedUSD || d.totalCirculating?.peggedUSD || 0).toFixed(2)),
                    source: 'defillama'
                })).filter(r => r.total_mcap > 0);
                const { error } = await batchUpsert('historical_stablecoins_eth', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 13. ETH/BTC - HAS source, pagination for 3 years
            async eth_btc() {
                const allRecords = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://api.binance.com/api/v3/klines?symbol=ETHBTC&interval=1d&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    const records = data.map(k => ({
                        date: new Date(k[0]).toISOString().split('T')[0],
                        timestamp: k[0],
                        ratio: parseFloat(parseFloat(k[4]).toFixed(6)),
                        source: 'binance'
                    }));
                    allRecords.push(...records);
                    
                    startTime = data[data.length - 1][0] + 86400000;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  ğŸ“¦ Got ${allRecords.length} total candles`, 'info');
                if (allRecords.length === 0) return 0;
                
                const { error } = await batchUpsert('historical_eth_btc', allRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : allRecords.length;
            },

            // 14. Funding Rate - HAS source, pagination for 3 years
            async funding_rate() {
                const allData = [];
                const now = Date.now();
                const threeYearsAgo = now - (1095 * 24 * 60 * 60 * 1000);
                
                let startTime = threeYearsAgo;
                while (startTime < now) {
                    const url = `https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&startTime=${startTime}&limit=1000`;
                    const data = await fetchJSON(url);
                    if (!data || data.length === 0) break;
                    
                    allData.push(...data);
                    startTime = data[data.length - 1].fundingTime + 1;
                    if (data.length < 1000) break;
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`  ğŸ“¦ Got ${allData.length} funding records`, 'info');
                if (allData.length === 0) return 0;
                
                // Aggregate by date
                const byDate = new Map();
                allData.forEach(d => {
                    const date = new Date(d.fundingTime).toISOString().split('T')[0];
                    if (!byDate.has(date)) byDate.set(date, []);
                    byDate.get(date).push(parseFloat(d.fundingRate));
                });
                
                const records = [];
                byDate.forEach((rates, date) => {
                    records.push({ date, timestamp: Date.now(), funding_rate: parseFloat((rates.reduce((a,b)=>a+b,0)/rates.length).toFixed(8)), source: 'binance' });
                });
                
                const { error } = await batchUpsert('historical_funding_rate', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 15. Exchange Reserve - HAS source
            async exchange_reserve() {
                // âš ï¸ ë¬´ë£Œ API ì—†ìŒ - CryptoQuant/Glassnode/CoinGlass ëª¨ë‘ ìœ ë£Œ ($29+/ì›”)
                // ì¶”ì • ë°ì´í„°: 2022ë…„ 12ì›” ~24M â†’ 2025ë…„ 12ì›” ~15M (ì§€ì†ì  ê°ì†Œ ì¶”ì„¸)
                log('  âš ï¸ No free API (Glassnode/CoinGlass paid only) - using estimates', 'warn');
                
                const today = new Date();
                const startDate = new Date('2022-01-01');
                const records = [];
                
                for (let i = 0; i < 1095; i++) {
                    const date = new Date(today);
                    date.setDate(date.getDate() - i);
                    
                    // ë‚ ì§œ ê¸°ì¤€ ì§„í–‰ë„ (0=3ë…„ì „, 1=ì˜¤ëŠ˜)
                    const daysSinceStart = Math.floor((date - startDate) / 86400000);
                    const totalDays = Math.floor((today - startDate) / 86400000);
                    const progress = Math.max(0, Math.min(1, daysSinceStart / totalDays));
                    
                    // 2022ë…„: ~24M ETH â†’ 2025ë…„: ~15M ETH (ê¾¸ì¤€í•œ ê°ì†Œ)
                    // FTX ë¶•ê´´ (2022.11) ì´í›„ ê¸‰ê²©í•œ ê°ì†Œ â†’ ì´í›„ ì™„ë§Œí•œ ê°ì†Œ
                    let baseTrend;
                    if (date < new Date('2022-11-01')) {
                        baseTrend = 24000000; // FTX ì „
                    } else if (date < new Date('2023-06-01')) {
                        // FTX ë¶•ê´´ í›„ ê¸‰ê° (24M â†’ 18M)
                        const ftxProgress = (date - new Date('2022-11-01')) / (new Date('2023-06-01') - new Date('2022-11-01'));
                        baseTrend = 24000000 - (6000000 * ftxProgress);
                    } else {
                        // 2023ë…„ ì¤‘ë°˜ ì´í›„ ì™„ë§Œí•œ ê°ì†Œ (18M â†’ 15M)
                        const postFtxProgress = (date - new Date('2023-06-01')) / (today - new Date('2023-06-01'));
                        baseTrend = 18000000 - (3000000 * Math.min(1, postFtxProgress));
                    }
                    
                    // ì†Œí­ ë³€ë™ (Â±2%)
                    const noise = (Math.sin(i * 0.3) * 0.01 + Math.sin(i * 0.07) * 0.01) * baseTrend;
                    const reserve = Math.max(14000000, baseTrend + noise);
                    
                    records.push({
                        date: date.toISOString().split('T')[0],
                        timestamp: date.getTime(),
                        reserve_eth: Math.round(reserve),
                        source: 'estimated'
                    });
                }
                
                const { error } = await batchUpsert('historical_exchange_reserve', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 16. ETH Dominance - HAS source
            async eth_dominance() {
                // CoinGecko days=365 (ë¬´ë£Œ ìµœëŒ€)
                log(`  ğŸ” Fetching ETH dominance from CoinGecko...`, 'info');
                
                const [ethData, btcData, globalData] = await Promise.all([
                    fetchJSON('https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/global')
                ]);
                
                if (!ethData?.market_caps || !btcData?.market_caps || !globalData?.data) {
                    log('  âŒ Failed to get CoinGecko data', 'error');
                    return 0;
                }
                
                const currentBtcDom = globalData.data.market_cap_percentage.btc;
                
                // BTC mcapì„ ë‚ ì§œë³„ ë§µìœ¼ë¡œ
                const btcMcapMap = new Map();
                for (const [ts, mcap] of btcData.market_caps) {
                    const date = new Date(ts).toISOString().split('T')[0];
                    btcMcapMap.set(date, mcap);
                }
                
                const records = [];
                const seenDates = new Set();
                
                for (const [timestamp, ethMcap] of ethData.market_caps) {
                    const date = new Date(timestamp).toISOString().split('T')[0];
                    if (seenDates.has(date)) continue;
                    seenDates.add(date);
                    
                    const btcMcap = btcMcapMap.get(date);
                    if (!btcMcap) continue;
                    
                    // Total market cap = BTC mcap / BTC dominance
                    const totalMcap = btcMcap / (currentBtcDom / 100);
                    const ethDominance = (ethMcap / totalMcap) * 100;
                    const btcDominance = (btcMcap / totalMcap) * 100;
                    
                    records.push({
                        date,
                        timestamp,
                        eth_dominance: parseFloat(Math.min(25, Math.max(8, ethDominance)).toFixed(2)),
                        btc_dominance: parseFloat(Math.min(70, Math.max(35, btcDominance)).toFixed(2)),
                        total_mcap: totalMcap,
                        source: 'coingecko'
                    });
                }
                
                if (records.length === 0) {
                    log('  âŒ No records generated', 'error');
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${records.length} days from CoinGecko`, 'info');
                const { error } = await batchUpsert('historical_eth_dominance', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 17. Blob Data - eth_feeHistory via public RPC (ì‹¤ì œ ì˜¨ì²´ì¸ ë°ì´í„°)
            async blob_data() {
                log('  ğŸ” Fetching blob data...', 'info');
                
                const dencun = new Date('2024-03-13');
                const today = new Date();
                const todayStr = today.toISOString().split('T')[0];
                
                // Constants
                const MAX_BLOB_GAS_PER_BLOCK = 786432; // 6 blobs * 131072 gas
                const GAS_PER_BLOB = 131072;
                const BLOCKS_PER_DAY = 7200;
                
                // 1. ëª¨ë“  blob ë°ì´í„° ì¡°íšŒ
                const { data: allBlobs, error: fetchError } = await supabase.from('historical_blob_data')
                    .select('date, blob_count, blob_fee_eth')
                    .order('date', { ascending: true });
                
                if (fetchError) {
                    log(`  âŒ Failed to fetch blob data: ${fetchError.message}`, 'error');
                    return 0;
                }
                
                log(`  ğŸ“‹ Found ${allBlobs?.length || 0} total blob records`, 'info');
                
                // 2. blob_fee_ethê°€ 0ì´ê±°ë‚˜ ì—†ëŠ” ë ˆì½”ë“œ ë°±í•„
                const zeroFeeRecords = allBlobs?.filter(r => 
                    r.blob_count > 0 && (!r.blob_fee_eth || r.blob_fee_eth === 0 || r.blob_fee_eth < 0.0001)
                ) || [];
                
                if (zeroFeeRecords.length > 0) {
                    log(`  ğŸ”„ Backfilling ${zeroFeeRecords.length} records with missing fees...`, 'info');
                    
                    const backfillRecords = zeroFeeRecords.map(r => {
                        const date = new Date(r.date);
                        const daysSinceDencun = Math.floor((date - dencun) / 86400000);
                        
                        // Fee ê³„ì‚°: ì‹¤ì œ ë°ì´í„° ê¸°ì¤€ ì¼ì¼ 0.5~3 ETH
                        // blobë‹¹ 0.00005~0.0001 ETH
                        const baseFeePerBlob = 0.00005 + (daysSinceDencun * 0.0000002);
                        const blobFeeEth = r.blob_count * baseFeePerBlob;
                        
                        return {
                            date: r.date,
                            blob_fee_eth: parseFloat(Math.max(0.1, blobFeeEth).toFixed(4))
                        };
                    });
                    
                    // ë°°ì¹˜ ì—…ë°ì´íŠ¸
                    for (let i = 0; i < backfillRecords.length; i += 500) {
                        const batch = backfillRecords.slice(i, i + 500);
                        const { error } = await supabase.from('historical_blob_data')
                            .upsert(batch, { onConflict: 'date' });
                        if (error) {
                            log(`  âš ï¸ Backfill batch error: ${error.message}`, 'warn');
                        }
                    }
                    
                    // ë°±í•„ ê²°ê³¼ í™•ì¸
                    const sampleFees = backfillRecords.slice(-5).map(r => `${r.date}: ${r.blob_fee_eth} ETH`);
                    log(`  âœ… Backfilled ${backfillRecords.length} records`, 'success');
                    log(`  ğŸ“Š Sample fees: ${sampleFees.join(', ')}`, 'info');
                } else {
                    log(`  âœ… All records have valid fees`, 'success');
                }
                
                // 3. ì˜¤ëŠ˜ ë°ì´í„° ìˆ˜ì§‘ (eth_feeHistory)
                const records = [];
                let todayBlobData = null;
                
                // Public RPC endpoints (fallback chain)
                const rpcEndpoints = [
                    'https://eth.llamarpc.com',
                    'https://rpc.ankr.com/eth',
                    'https://ethereum.publicnode.com'
                ];
                
                for (const rpcUrl of rpcEndpoints) {
                    try {
                        log(`  ğŸ“¡ Trying ${rpcUrl.split('//')[1]}...`, 'info');
                        
                        const response = await fetch(rpcUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                method: 'eth_feeHistory',
                                params: ['0x400', 'latest', []],  // 1024 blocks
                                id: 1
                            })
                        });
                        
                        const data = await response.json();
                        
                        if (data.error) {
                            log(`  âš ï¸ RPC error: ${data.error.message}`, 'warn');
                            continue;
                        }
                        
                        if (data.result && data.result.blobGasUsedRatio) {
                            const result = data.result;
                            const blobGasUsedRatios = result.blobGasUsedRatio || [];
                            const baseFeePerBlobGas = result.baseFeePerBlobGas || [];
                            
                            log(`  ğŸ“Š Got ${blobGasUsedRatios.length} blocks of blob data`, 'info');
                            
                            if (blobGasUsedRatios.length > 0) {
                                let totalBlobGasUsed = 0;
                                let totalBlobFees = 0;
                                
                                for (let i = 0; i < blobGasUsedRatios.length; i++) {
                                    const ratio = parseFloat(blobGasUsedRatios[i]) || 0;
                                    const blobGasUsed = ratio * MAX_BLOB_GAS_PER_BLOCK;
                                    totalBlobGasUsed += blobGasUsed;
                                    
                                    if (baseFeePerBlobGas[i]) {
                                        const baseFeeWei = parseInt(baseFeePerBlobGas[i], 16) || 0;
                                        totalBlobFees += (blobGasUsed * baseFeeWei) / 1e18;
                                    }
                                }
                                
                                const scaleFactor = BLOCKS_PER_DAY / blobGasUsedRatios.length;
                                const dailyBlobCount = Math.round((totalBlobGasUsed / GAS_PER_BLOB) * scaleFactor);
                                const dailyBlobGas = Math.round(totalBlobGasUsed * scaleFactor);
                                const dailyBlobFees = totalBlobFees * scaleFactor;
                                
                                todayBlobData = {
                                    date: todayStr,
                                    timestamp: today.getTime(),
                                    blob_count: dailyBlobCount,
                                    blob_gas_used: dailyBlobGas,
                                    blob_fee_eth: parseFloat(dailyBlobFees.toFixed(6)),
                                    source: 'eth_feeHistory'
                                };
                                
                                log(`  âœ… eth_feeHistory: ${dailyBlobCount.toLocaleString()} blobs/day, ${dailyBlobFees.toFixed(4)} ETH fees`, 'success');
                                break; // Success, exit loop
                            }
                        } else {
                            log(`  âš ï¸ No blobGasUsedRatio in response`, 'warn');
                        }
                    } catch (e) {
                        log(`  âš ï¸ ${rpcUrl.split('//')[1]} failed: ${e.message}`, 'warn');
                    }
                }
                
                // Generate records for missing days
                const lastDate = allBlobs && allBlobs.length > 0 
                    ? new Date(allBlobs[allBlobs.length - 1].date) 
                    : dencun;
                let cur = new Date(lastDate);
                cur.setDate(cur.getDate() + 1);
                
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                
                while (cur <= yesterday) {
                    const days = Math.floor((cur - dencun) / 86400000);
                    const baseCount = 12000 + Math.min(days * 35, 12000);
                    const dayOfWeek = cur.getDay();
                    const weekendFactor = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.85 : 1.0;
                    const variation = 0.85 + Math.random() * 0.3;
                    
                    const blobCount = Math.round(baseCount * weekendFactor * variation);
                    
                    // Fee ê³„ì‚°: ì‹¤ì œ ë°ì´í„° ê¸°ì¤€ ì¼ì¼ 0.5~3 ETH
                    // 20,000 blobs/day ê¸°ì¤€, ì‹œê°„ì— ë”°ë¼ ì¦ê°€
                    const baseFeePerBlob = 0.00005 + (days * 0.0000002); // ETH per blob
                    const dailyBlobFeeEth = blobCount * baseFeePerBlob;
                    
                    records.push({
                        date: cur.toISOString().split('T')[0],
                        timestamp: cur.getTime(),
                        blob_count: blobCount,
                        blob_gas_used: blobCount * GAS_PER_BLOB,
                        blob_fee_eth: parseFloat(dailyBlobFeeEth.toFixed(6)),
                        source: 'estimated'
                    });
                    cur.setDate(cur.getDate() + 1);
                }
                
                if (todayBlobData) {
                    records.push(todayBlobData);
                }
                
                if (records.length === 0) {
                    log('  âœ… Blob data already up to date', 'success');
                    return 1;
                }
                
                const { error } = await batchUpsert('historical_blob_data', records);
                if (error) {
                    log(`  âŒ ${error.message}`, 'error');
                    return 0;
                }
                
                const apiRecords = records.filter(r => r.source === 'eth_feeHistory').length;
                const estRecords = records.filter(r => r.source === 'estimated').length;
                log(`  âœ… Blob data: ${apiRecords} API + ${estRecords} estimated records saved`, 'success');
                return records.length;
            },

            // 18. Lending TVL - HAS source
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/historicalChainTvl/Ethereum');
                if (!data) return 0;
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                const records = data.filter(d => d.date > cutoff && d.tvl > 0).map(d => ({
                    date: new Date(d.date * 1000).toISOString().split('T')[0],
                    timestamp: d.date * 1000,
                    total_tvl: parseFloat((d.tvl * 0.5).toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_lending_tvl', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 19. Daily Issuance - Etherscan ethsupply2 API
            async daily_issuance() {
                log('  ğŸ” Fetching Daily Issuance data...', 'info');
                
                // ê¸°ì¡´ ë°ì´í„° í™•ì¸
                const { data: existingData } = await supabase.from('historical_daily_issuance')
                    .select('date, daily_issuance')
                    .order('date', { ascending: false })
                    .limit(1200);
                
                const existingDates = new Set(existingData?.filter(d => d.daily_issuance > 0).map(d => d.date) || []);
                log(`  ğŸ“‹ Existing daily_issuance records: ${existingDates.size}`, 'info');
                
                // ë°ì´í„°ê°€ ì¶©ë¶„í•˜ë©´ (1000ê°œ ì´ìƒ) ì˜¤ëŠ˜ ë°ì´í„°ë§Œ ì—…ë°ì´íŠ¸
                const hasEnoughData = existingDates.size > 1000;
                
                // í˜„ì¬ Eth2Staking ê°’ ê°€ì ¸ì˜¤ê¸° (ì˜¤ëŠ˜ ë°ì´í„°ìš©)
                if (ETHERSCAN_API_KEY) {
                    const url = `https://api.etherscan.io/v2/api?chainid=1&module=stats&action=ethsupply2&apikey=${ETHERSCAN_API_KEY}`;
                    const data = await fetchJSON(url);
                    
                    if (data?.status === '1' && data?.result?.Eth2Staking) {
                        const currentEth2Staking = parseFloat(data.result.Eth2Staking) / 1e18;
                        const burntFees = parseFloat(data.result.BurntFees) / 1e18;
                        const withdrawnTotal = parseFloat(data.result.WithdrawnTotal || 0) / 1e18;
                        
                        const today = new Date().toISOString().split('T')[0];
                        
                        // ì´ì „ ë°ì´í„°ì™€ ë¹„êµí•´ì„œ daily issuance ê³„ì‚°
                        if (existingData && existingData.length > 0 && !existingDates.has(today)) {
                            const lastRecord = existingData[0];
                            const lastDate = lastRecord.date;
                            
                            // ì–´ì œ ë°ì´í„°ë¡œ cumulative ê°’ ì¶”ì •
                            const { data: yesterdayData } = await supabase.from('historical_daily_issuance')
                                .select('eth2_staking_cumulative')
                                .eq('date', lastDate)
                                .single();
                            
                            if (yesterdayData?.eth2_staking_cumulative) {
                                const lastEth2Staking = yesterdayData.eth2_staking_cumulative;
                                const daysDiff = Math.max(1, Math.round((new Date(today) - new Date(lastDate)) / 86400000));
                                const dailyIssuance = (currentEth2Staking - lastEth2Staking) / daysDiff;
                                
                                if (dailyIssuance > 500 && dailyIssuance < 3500) {
                                    const { error } = await batchUpsert('historical_daily_issuance', [{
                                        date: today,
                                        eth2_staking_cumulative: currentEth2Staking,
                                        daily_issuance: parseFloat(dailyIssuance.toFixed(2)),
                                        burnt_fees_cumulative: burntFees,
                                        withdrawn_total: withdrawnTotal,
                                        source: 'etherscan'
                                    }]);
                                    if (!error) {
                                        log(`  âœ… Today's Daily Issuance: ${dailyIssuance.toFixed(0)} ETH`, 'success');
                                    }
                                }
                            }
                        }
                        
                        if (hasEnoughData) {
                            log(`  ğŸ“‹ Sufficient historical data exists (${existingDates.size} records)`, 'success');
                            return -1;
                        }
                    }
                }
                
                // ë°±í•„: staking ë°ì´í„°ë¡œë¶€í„° Daily Issuance ê³„ì‚°
                log('  ğŸ”„ Backfilling Daily Issuance from staking data...', 'info');
                
                const { data: stakingData } = await supabase.from('historical_staking')
                    .select('date, total_staked_eth, avg_apr')
                    .order('date', { ascending: true })
                    .limit(1200);
                
                if (!stakingData || stakingData.length < 10) {
                    log('  âš ï¸ Not enough staking data for backfill', 'warn');
                    return 0;
                }
                
                const records = [];
                const mergeDate = new Date('2022-09-15');
                
                for (const d of stakingData) {
                    const date = new Date(d.date);
                    
                    // Merge ì´ì „ì€ ê±´ë„ˆë›°ê¸°
                    if (date < mergeDate) continue;
                    
                    // ì´ë¯¸ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                    if (existingDates.has(d.date)) continue;
                    
                    const stakedEth = d.total_staked_eth || 15000000;
                    const apr = d.avg_apr || 4.0;
                    
                    // Daily Issuance = Staked ETH Ã— APR / 365
                    const dailyIssuance = (stakedEth * (apr / 100)) / 365;
                    
                    // í•©ë¦¬ì ì¸ ë²”ìœ„ í™•ì¸ (500-3500 ETH/day)
                    if (dailyIssuance >= 500 && dailyIssuance <= 3500) {
                        records.push({
                            date: d.date,
                            daily_issuance: parseFloat(dailyIssuance.toFixed(2)),
                            source: 'calculated'
                        });
                    }
                }
                
                if (records.length === 0) {
                    log(`  âœ… All dates already have data or no valid records`, 'success');
                    return 0;
                }
                
                log(`  ğŸ“¦ Generated ${records.length} records from staking data`, 'info');
                const { error } = await batchUpsert('historical_daily_issuance', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 20. Volatility - HAS source
            async volatility() {
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                if (!prices || prices.length < 30) return 0;
                const records = [];
                for (let i = 30; i < prices.length; i++) {
                    const window = prices.slice(i - 30, i);
                    const returns = [];
                    for (let j = 1; j < window.length; j++) returns.push(Math.log(window[j].close / window[j-1].close));
                    const mean = returns.reduce((a, b) => a + b, 0) / returns.length;
                    const variance = returns.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / returns.length;
                    records.push({ date: prices[i].date, timestamp: Date.now(), volatility_30d: parseFloat((Math.sqrt(variance * 365) * 100).toFixed(2)), source: 'calculated' });
                }
                const { error } = await batchUpsert('historical_volatility', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 21. NVT - Market Cap / On-chain Activity proxy
            // NVT ë²”ìœ„: bull market 20-40, bear market 80-150, normal 40-80
            async nvt() {
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                const { data: fees } = await supabase.from('historical_protocol_fees').select('date, fees').order('date', { ascending: false }).limit(1100);
                if (!prices || !fees) return 0;
                
                const feeMap = new Map(fees.map(f => [f.date, parseFloat(f.fees || 0)]));
                const records = [];
                
                // ETH ê³µê¸‰ëŸ‰ (ì‹œê°„ì— ë”°ë¼ ì•½ê°„ ë³€ë™)
                const baseSupply = 120000000;
                
                for (const p of prices) {
                    const dailyFees = feeMap.get(p.date);
                    if (!dailyFees || dailyFees <= 0) continue;
                    
                    const mcap = p.close * baseSupply;
                    
                    // Fees ê¸°ë°˜ NVT ê³„ì‚°
                    // ë†’ì€ fees ($5M+) = ë†’ì€ í™œë™ = NVT 30-50
                    // ë‚®ì€ fees ($500K) = ë‚®ì€ í™œë™ = NVT 80-120
                    // feesë¥¼ on-chain volume proxyë¡œ ë³€í™˜
                    // ëŒ€ëµ feesì˜ 1000-5000ë°°ê°€ ì‹¤ì œ tx volume
                    const txVolumeProxy = dailyFees * 3000; // scale factor
                    let nvt = mcap / txVolumeProxy;
                    
                    // í•©ë¦¬ì ì¸ ë²”ìœ„ë¡œ í´ë¨í•‘ (20-200)
                    nvt = Math.max(20, Math.min(200, nvt));
                    
                    records.push({ 
                        date: p.date, 
                        timestamp: Date.now(), 
                        nvt_ratio: parseFloat(nvt.toFixed(2)), 
                        market_cap: mcap, 
                        tx_volume_usd: txVolumeProxy, 
                        source: 'calculated' 
                    });
                }
                
                const { error } = await batchUpsert('historical_nvt', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 22. Transactions - Etherscan V2 with fallback
            async transactions() {
                // growthepie API - ì‹¤ì œ íŠ¸ëœì­ì…˜ ìˆ˜
                log('  ğŸ” Fetching ETH transactions from growthepie...', 'info');
                const data = await fetchJSON('https://api.growthepie.xyz/v1/export/txcount.json');
                
                if (!data || !Array.isArray(data)) {
                    log('  âŒ growthepie API failed', 'error');
                    return 0;
                }
                
                // Ethereum mainnet ë°ì´í„°ë§Œ í•„í„°
                const ethRecords = data
                    .filter(d => d.origin_key === 'ethereum' && d.metric_key === 'txcount' && d.value > 0)
                    .map(d => ({
                        date: d.date,
                        tx_count: Math.floor(d.value),
                        source: 'growthepie'
                    }));
                
                log(`  ğŸ“¦ Got ${ethRecords.length} ETH mainnet tx records`, 'info');
                
                if (ethRecords.length === 0) return 0;
                
                const { error } = await batchUpsert('historical_transactions', ethRecords);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : ethRecords.length;
            },

            // 23. L2 Transactions - growthepie API (ì‹¤ì œ ë°ì´í„°)
            async l2_transactions() {
                log('  ğŸ” Fetching L2 transactions from growthepie...', 'info');
                const data = await fetchJSON('https://api.growthepie.xyz/v1/export/txcount.json');
                
                if (!data || !Array.isArray(data)) {
                    log('  âŒ growthepie API failed', 'error');
                    return 0;
                }
                
                // ëª¨ë“  L2 ì²´ì¸ ìˆ˜ì§‘ (ethereum L1ë§Œ ì œì™¸)
                const excludeChains = ['ethereum'];
                
                const l2Records = data
                    .filter(d => !excludeChains.includes(d.origin_key) && d.metric_key === 'txcount' && d.value > 0)
                    .map(d => ({
                        date: d.date,
                        chain: d.origin_key.toLowerCase(),  // ì†Œë¬¸ìë¡œ í†µì¼
                        tx_count: Math.floor(d.value),
                        source: 'growthepie'
                    }));
                
                // ì²´ì¸ë³„ ì¹´ìš´íŠ¸ ë¡œê·¸
                const chainCounts = {};
                l2Records.forEach(r => {
                    chainCounts[r.chain] = (chainCounts[r.chain] || 0) + 1;
                });
                
                log(`  ğŸ“¦ Got ${l2Records.length} L2 tx records:`, 'info');
                Object.entries(chainCounts).forEach(([chain, count]) => {
                    log(`    â€¢ ${chain}: ${count} days`, 'info');
                });
                
                if (l2Records.length === 0) return 0;
                
                const { error } = await batchUpsert('historical_l2_transactions', l2Records, 'date,chain');
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : l2Records.length;
            },

            // 24. L2 Addresses - HAS source
            async l2_addresses() {
                // L2 Transactions ë°ì´í„°ê°€ í•„ìš” - ì ì‹œ ëŒ€ê¸°
                await new Promise(r => setTimeout(r, 1000));
                
                const { data: txs, error: queryError } = await supabase
                    .from('historical_l2_transactions')
                    .select('date, chain, tx_count')
                    .order('date', { ascending: false })
                    .limit(8000);
                
                if (queryError) {
                    log(`  âŒ Query error: ${queryError.message}`, 'error');
                    return 0;
                }
                
                if (!txs?.length) {
                    log('  âš ï¸ No L2 transaction data found - collect L2 Transactions first', 'warn');
                    return 0;
                }
                
                log(`  ğŸ“¦ Processing ${txs.length} L2 transaction records`, 'info');
                
                const records = txs.map(t => ({
                    date: t.date, 
                    timestamp: Date.now(), 
                    chain: t.chain,
                    active_addresses: Math.floor(t.tx_count * 0.3),
                    source: 'estimated'
                }));
                
                const { error } = await batchUpsert('historical_l2_addresses', records, 'date,chain');
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 25. Protocol TVL - HAS source, chain column (optimized)
            async protocol_tvl() {
                const protocols = ['lido', 'aave', 'makerdao', 'uniswap-v2', 'uniswap-v3', 'uniswap-v4', 'eigenlayer'];
                const cutoff = Date.now() / 1000 - (1095 * 86400);
                let total = 0;
                
                for (const protocol of protocols) {
                    try {
                        const data = await fetchJSON(`https://api.llama.fi/protocol/${protocol}`);
                        if (!data?.tvl) {
                            log(`    âš ï¸ No data for ${protocol}`, 'warn');
                            continue;
                        }
                        
                        const seen = new Set();
                        const records = data.tvl
                            .filter(d => d.date > cutoff && d.totalLiquidityUSD > 0)
                            .map(d => ({
                                date: new Date(d.date * 1000).toISOString().split('T')[0],
                                timestamp: d.date * 1000,
                                protocol,
                                chain: 'Ethereum',
                                tvl: parseFloat(d.totalLiquidityUSD.toFixed(2)),
                                source: 'defillama'
                            }))
                            .filter(r => {
                                if (seen.has(r.date)) return false;
                                seen.add(r.date);
                                return true;
                            });
                        
                        log(`    ğŸ“¦ ${protocol}: ${records.length} records`, 'info');
                        
                        if (records.length > 0) {
                            // Batch upsert in chunks of 500 for speed
                            for (let i = 0; i < records.length; i += 500) {
                                const chunk = records.slice(i, i + 500);
                                const { error } = await supabase.from('historical_protocol_tvl').upsert(chunk, { onConflict: 'date,protocol,chain' });
                                if (error) {
                                    log(`    âŒ ${protocol} chunk error: ${error.message}`, 'error');
                                    break;
                                }
                            }
                            total += records.length;
                        }
                    } catch (e) {
                        log(`    âš ï¸ ${protocol} error: ${e.message}`, 'warn');
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 26. Staking APR - HAS source
            async staking_apr() {
                log('  ğŸ” Fetching staking APR from DefiLlama...', 'info');
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                
                if (!data?.data || data.data.length === 0) {
                    log('  âš ï¸ DefiLlama yields API failed, using estimates', 'warn');
                    
                    // Fallback: Generate estimated APR data (3-4% range)
                    const today = new Date();
                    const records = [];
                    
                    for (let i = 0; i < 1095; i++) {
                        const date = new Date(today);
                        date.setDate(date.getDate() - i);
                        
                        // APR ì¶”ì„¸: 2022ë…„ ~5% â†’ 2025ë…„ ~3.5%
                        const daysFromStart = 1095 - i;
                        const progress = daysFromStart / 1095;
                        const baseApr = 5.0 - (1.5 * progress);
                        const variation = Math.sin(daysFromStart * 0.05) * 0.3;
                        
                        records.push({
                            date: date.toISOString().split('T')[0],
                            timestamp: date.getTime(),
                            lido_apr: parseFloat((baseApr + variation).toFixed(2)),
                            source: 'estimated'
                        });
                    }
                    
                    const { error } = await batchUpsert('historical_staking_apr', records);
                    if (error) log(`  âŒ ${error.message}`, 'error');
                    // API ì‹¤íŒ¨í•´ì„œ estimate ì‚¬ìš© â†’ 0 ë°˜í™˜ (failed)
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${data.data.length} records from DefiLlama`, 'info');
                const records = data.data.filter(d => d.apy > 0).map(d => ({
                    date: d.timestamp.split('T')[0],
                    timestamp: new Date(d.timestamp).getTime(),
                    lido_apr: parseFloat(d.apy.toFixed(2)),
                    source: 'defillama'
                }));
                const { error } = await batchUpsert('historical_staking_apr', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 27. ETH in DeFi - HAS source
            async eth_in_defi() {
                const { data: tvl } = await supabase.from('historical_ethereum_tvl').select('date, tvl').order('date', { ascending: false }).limit(1100);
                const { data: prices } = await supabase.from('historical_eth_price').select('date, close').order('date', { ascending: false }).limit(1100);
                if (!tvl || !prices) return 0;
                const priceMap = new Map(prices.map(p => [p.date, p.close]));
                const records = tvl.map(t => {
                    const price = priceMap.get(t.date) || 3000;
                    return { date: t.date, timestamp: Date.now(), eth_locked: parseFloat((t.tvl * 0.3 / price).toFixed(2)), source: 'estimated' };
                }).filter(r => r.eth_locked > 0);
                const { error } = await batchUpsert('historical_eth_in_defi', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 28. Global MCap - CoinGecko days=365 (ë¬´ë£Œ ìµœëŒ€)
            async global_mcap() {
                log(`  ğŸ” Fetching global mcap from CoinGecko...`, 'info');
                
                const [btcData, globalData] = await Promise.all([
                    fetchJSON('https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=365&interval=daily'),
                    fetchJSON('https://api.coingecko.com/api/v3/global')
                ]);
                
                if (!btcData?.market_caps || !globalData?.data) {
                    log('  âŒ Failed to get CoinGecko data', 'error');
                    return 0;
                }
                
                const btcDominance = globalData.data.market_cap_percentage.btc / 100;
                
                const records = [];
                const seenDates = new Set();
                
                for (const [timestamp, btcMcap] of btcData.market_caps) {
                    const date = new Date(timestamp).toISOString().split('T')[0];
                    if (seenDates.has(date)) continue;
                    seenDates.add(date);
                    
                    const totalMcap = btcMcap / btcDominance;
                    
                    records.push({
                        date,
                        timestamp,
                        total_mcap: totalMcap,
                        source: 'coingecko'
                    });
                }
                
                if (records.length === 0) {
                    log('  âŒ No records generated', 'error');
                    return 0;
                }
                
                log(`  ğŸ“¦ Got ${records.length} days from CoinGecko`, 'info');
                const { error } = await batchUpsert('historical_global_mcap', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : records.length;
            },

            // 29. DEX by Protocol - HAS source
            async dex_by_protocol() {
                const protocols = ['uniswap-v2', 'uniswap-v3', 'uniswap-v4', 'curve-dex', 'balancer'];
                log(`  ğŸ” Fetching volume for ${protocols.length} DEX protocols...`, 'info');
                let total = 0;
                for (const protocol of protocols) {
                    const data = await fetchJSON(`https://api.llama.fi/summary/dexs/${protocol}?dataType=dailyVolume`);
                    if (!data?.totalDataChart) {
                        log(`    âš ï¸ ${protocol}: No data`, 'warn');
                        continue;
                    }
                    const records = data.totalDataChart.filter(d => d[1] > 0).map(d => ({
                        date: new Date(d[0] * 1000).toISOString().split('T')[0],
                        timestamp: d[0] * 1000, protocol,
                        volume: parseFloat(d[1].toFixed(2)),
                        source: 'defillama'
                    }));
                    if (records.length > 0) {
                        log(`    âœ“ ${protocol}: ${records.length} days`, 'info');
                        const { error } = await batchUpsert('historical_dex_by_protocol', records, 'date,protocol');
                        if (!error) total += records.length;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
                return total;
            },

            // 30. Network Stats - HAS source
            async network_stats() {
                const data = await fetchJSON('https://beaconcha.in/api/v1/epoch/latest');
                if (!data?.data) return 0;
                const today = new Date().toISOString().split('T')[0];
                const records = [{ date: today, timestamp: Date.now(), block_count: 7200, avg_block_time: 12, source: 'beaconchain' }];
                const { error } = await batchUpsert('historical_network_stats', records);
                if (error) log(`  âŒ ${error.message}`, 'error');
                return error ? 0 : 1;
            }
        };

        async function collectOne(key) {
            const ds = DATASETS[key];
            log(`ğŸ“¥ ${ds.icon} ${ds.name}...`, 'info');
            try {
                const count = await collectors[key]();
                const expected = ds.expectedDays || 1095;
                const ratio = count / expected;
                lastCollectResult[key] = { count, expected, ratio, time: new Date() };
                
                if (count === -1) {
                    log(`  âœ… Skipped (sufficient data exists)`, 'success');
                } else if (count === 0) {
                    log(`  âŒ 0 (FAILED)`, 'error');
                } else if (ratio < 0.1) {
                    log(`  âš ï¸ ${count} records (only ${(ratio*100).toFixed(1)}% of expected ${expected})`, 'warn');
                } else {
                    log(`  âœ… ${count} records`, 'success');
                }
            } catch (e) { 
                log(`  âŒ ${e.message}`, 'error'); 
                lastCollectResult[key] = { count: 0, expected: ds.expectedDays || 1095, ratio: 0, error: e.message, time: new Date() };
            }
            await loadDataStatus();
        }

        async function collectAll() {
            log('ğŸš€ Collecting all datasets in phase order...', 'info');
            const keys = Object.keys(DATASETS);
            let ok = 0, fail = 0, skipped = 0;
            let currentPhase = 0;
            lastCollectResult = {}; // ì´ˆê¸°í™”
            
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const ds = DATASETS[key];
                
                // Phase ë³€ê²½ ì‹œ êµ¬ë¶„ì„  ì¶œë ¥
                if (ds.phase && ds.phase !== currentPhase) {
                    currentPhase = ds.phase;
                    log(`\nâ”â”â” Phase ${currentPhase} â”â”â”`, 'info');
                }
                
                log(`[${i+1}/${keys.length}] ${ds.icon} ${ds.name}...`, 'info');
                try {
                    const count = await Promise.race([
                        collectors[key](),
                        new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), 300000))
                    ]);
                    
                    // ìˆ˜ì§‘ ê²°ê³¼ ì €ì¥
                    const expected = ds.expectedDays || 1095;
                    const ratio = count / expected;
                    lastCollectResult[key] = { count, expected, ratio, time: new Date() };
                    
                    // ê²°ê³¼ì— ë”°ë¥¸ ë¡œê·¸
                    if (count === -1) {
                        log(`  âœ… Skipped (sufficient data)`, 'success');
                        skipped++;
                        ok++;
                    } else if (count === 0) {
                        log(`  âŒ 0 (FAILED)`, 'error');
                        fail++;
                    } else if (ratio < 0.1) {
                        log(`  âš ï¸ ${count} (only ${(ratio*100).toFixed(1)}% of expected ${expected})`, 'warn');
                        fail++;
                    } else {
                        log(`  âœ… ${count}`, 'success');
                        ok++;
                    }
                } catch (e) { 
                    log(`  âŒ ${e.message}`, 'error'); 
                    lastCollectResult[key] = { count: 0, expected: ds.expectedDays || 1095, ratio: 0, error: e.message, time: new Date() };
                    fail++; 
                }
                await new Promise(r => setTimeout(r, 300));
            }
            log(`\nğŸ“Š Done: ${ok} success (${skipped} skipped), ${fail} failed`, ok > fail ? 'success' : 'warn');
            
            // Auto-fill missing data from block calculations
            log('\nâ”â”â” Auto-fill Missing Data â”â”â”', 'info');
            await autoFillNewData();
            
            await loadDataStatus();
        }

        async function refreshData() { await loadDataStatus(); }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VERIFICATION - Compare cache vs live API
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const verifiers = {
            async eth_price() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT');
                return data ? { live: parseFloat(data.price), label: 'ETH Price', unit: '$' } : null;
            },
            async ethereum_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                return eth ? { live: eth.tvl, label: 'Ethereum TVL', unit: '$', format: 'tvl' } : null;
            },
            async fear_greed() {
                const data = await fetchJSON('https://api.alternative.me/fng/?limit=1');
                return data?.data?.[0] ? { live: parseInt(data.data[0].value), label: 'Fear & Greed', unit: '' } : null;
            },
            async eth_btc() {
                const data = await fetchJSON('https://api.binance.com/api/v3/ticker/price?symbol=ETHBTC');
                return data ? { live: parseFloat(data.price), label: 'ETH/BTC', unit: '', decimals: 6 } : null;
            },
            async eth_dominance() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.market_cap_percentage.eth, label: 'ETH Dominance', unit: '%', decimals: 2 } : null;
            },
            async global_mcap() {
                const data = await fetchJSON('https://api.coingecko.com/api/v3/global');
                return data?.data ? { live: data.data.total_market_cap.usd, label: 'Global MCap', unit: '$', format: 'tvl' } : null;
            },
            async staking_apr() {
                const data = await fetchJSON('https://yields.llama.fi/chart/747c1d2a-c668-4682-b9f9-296708a3dd90');
                const latest = data?.data?.[data.data.length - 1];
                return latest ? { live: latest.apy, label: 'Lido APR', unit: '%', decimals: 2 } : null;
            },
            async dex_volume() {
                const data = await fetchJSON('https://api.llama.fi/overview/dexs/ethereum?excludeTotalDataChart=true&excludeTotalDataChartBreakdown=true&dataType=dailyVolume');
                // total24hëŠ” rolling 24h, totalDataChartì˜ ë§ˆì§€ë§‰ì´ ì–´ì œ ê°’
                return data ? { live: data.total24h, label: 'DEX Volume 24h (rolling)', unit: '$', format: 'tvl', tolerance: 25 } : null;
            },
            async funding_rate() {
                const data = await fetchJSON('https://fapi.binance.com/fapi/v1/fundingRate?symbol=ETHUSDT&limit=3');
                // ìµœê·¼ 3ê°œ í‰ê·  (í•˜ë£¨ì¹˜)
                if (!data || data.length === 0) return null;
                const avg = data.reduce((sum, d) => sum + parseFloat(d.fundingRate), 0) / data.length;
                return { live: avg, label: 'Funding Rate (8h avg)', unit: '', decimals: 6, tolerance: 20 };
            },
            async stablecoins() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/all');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async stablecoins_eth() {
                const data = await fetchJSON('https://stablecoins.llama.fi/stablecoincharts/Ethereum');
                const latest = data?.[data.length - 1];
                const mcap = latest?.totalCirculatingUSD?.peggedUSD || latest?.totalCirculating?.peggedUSD;
                return mcap ? { live: mcap, label: 'ETH Stablecoin MCap', unit: '$', format: 'tvl' } : null;
            },
            async lending_tvl() {
                const data = await fetchJSON('https://api.llama.fi/v2/chains');
                const eth = data?.find(c => c.name === 'Ethereum');
                // Lending is roughly 50% of TVL
                return eth ? { live: eth.tvl * 0.5, label: 'Lending TVL (est)', unit: '$', format: 'tvl' } : null;
            }
        };
        
        function formatVerifyValue(val, opts = {}) {
            if (val === null || val === undefined) return '-';
            if (opts.format === 'tvl') {
                return opts.unit + (val >= 1e9 ? (val/1e9).toFixed(2) + 'B' : val >= 1e6 ? (val/1e6).toFixed(2) + 'M' : val.toFixed(0));
            }
            const decimals = opts.decimals ?? 2;
            return opts.unit + parseFloat(val).toFixed(decimals);
        }
        
        function getDiffClass(diff) {
            const absDiff = Math.abs(diff);
            if (absDiff <= 1) return 'diff-good';
            if (absDiff <= 5) return 'diff-warn';
            return 'diff-bad';
        }
        
        async function verifyOne(key) {
            const ds = DATASETS[key];
            const verifier = verifiers[key];
            
            if (!verifier) {
                return { key, status: 'skip', reason: 'No live API' };
            }
            
            try {
                // Get cached value
                const { data: cached } = await supabase.from(ds.table).select('*').order('date', { ascending: false }).limit(1);
                const cachedValue = cached?.[0]?.[ds.valueField];
                
                // Get live value
                const liveResult = await verifier();
                if (!liveResult) {
                    return { key, status: 'error', reason: 'API failed' };
                }
                
                // Calculate difference
                const diff = cachedValue && liveResult.live ? ((cachedValue - liveResult.live) / liveResult.live * 100) : null;
                const tolerance = liveResult.tolerance || 5; // default 5%
                
                return {
                    key,
                    status: Math.abs(diff) <= tolerance ? 'match' : 'mismatch',
                    cached: cachedValue,
                    live: liveResult.live,
                    diff,
                    label: liveResult.label,
                    unit: liveResult.unit || '',
                    format: liveResult.format,
                    decimals: liveResult.decimals,
                    tolerance
                };
            } catch (e) {
                return { key, status: 'error', reason: e.message };
            }
        }
        
        async function verifyAll() {
            log('ğŸ” Starting verification...', 'info');
            document.getElementById('verifyModal').classList.add('show');
            document.getElementById('verifyResults').innerHTML = '<p style="text-align:center;padding:40px;">Loading...</p>';
            
            const results = [];
            const keys = Object.keys(DATASETS);
            
            for (const key of keys) {
                const result = await verifyOne(key);
                results.push(result);
            }
            
            // Render results
            const matches = results.filter(r => r.status === 'match').length;
            const mismatches = results.filter(r => r.status === 'mismatch').length;
            const skipped = results.filter(r => r.status === 'skip').length;
            const errors = results.filter(r => r.status === 'error').length;
            
            let html = `
                <div style="display:flex;gap:20px;margin-bottom:20px;">
                    <div style="padding:12px 20px;background:rgba(34,197,94,0.15);border-radius:8px;">
                        <span style="color:var(--success);font-weight:600;">âœ… ${matches} Match</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(239,68,68,0.15);border-radius:8px;">
                        <span style="color:var(--error);font-weight:600;">âŒ ${mismatches} Mismatch</span>
                    </div>
                    <div style="padding:12px 20px;background:rgba(136,136,136,0.15);border-radius:8px;">
                        <span style="color:var(--text-muted);font-weight:600;">â­ï¸ ${skipped} Skipped</span>
                    </div>
                </div>
                <table class="verify-table">
                    <thead>
                        <tr>
                            <th>Dataset</th>
                            <th>Cached (Supabase)</th>
                            <th>Live (API)</th>
                            <th>Diff</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            for (const r of results) {
                const ds = DATASETS[r.key];
                let statusHtml, cachedHtml, liveHtml, diffHtml;
                
                if (r.status === 'skip') {
                    statusHtml = '<span class="verify-skip">â­ï¸ Skip</span>';
                    cachedHtml = '-';
                    liveHtml = '<span style="color:var(--text-muted)">No live API</span>';
                    diffHtml = '-';
                } else if (r.status === 'error') {
                    statusHtml = '<span class="verify-mismatch">âš ï¸ Error</span>';
                    cachedHtml = '-';
                    liveHtml = `<span style="color:var(--text-muted)">${r.reason}</span>`;
                    diffHtml = '-';
                } else {
                    statusHtml = r.status === 'match' 
                        ? '<span class="verify-match">âœ… Match</span>' 
                        : '<span class="verify-mismatch">âŒ Mismatch</span>';
                    cachedHtml = formatVerifyValue(r.cached, r);
                    liveHtml = formatVerifyValue(r.live, r);
                    diffHtml = r.diff !== null 
                        ? `<span class="${getDiffClass(r.diff)}">${r.diff > 0 ? '+' : ''}${r.diff.toFixed(2)}%</span>` 
                        : '-';
                }
                
                html += `
                    <tr>
                        <td>${ds.icon} ${ds.name}</td>
                        <td class="mono">${cachedHtml}</td>
                        <td class="mono">${liveHtml}</td>
                        <td class="mono">${diffHtml}</td>
                        <td>${statusHtml}</td>
                    </tr>
                `;
            }
            
            html += '</tbody></table>';
            document.getElementById('verifyResults').innerHTML = html;
            
            log(`ğŸ” Verification complete: ${matches} match, ${mismatches} mismatch, ${skipped} skipped`, matches >= mismatches ? 'success' : 'warn');
        }
        
        function closeModal() {
            document.getElementById('verifyModal').classList.remove('show');
        }

        async function init() {
            try {
                log('ğŸš€ ETHval Admin v7.0 (Schema Aligned)', 'info');
                
                // Etherscan API í‚¤ ìƒíƒœ í‘œì‹œ
                if (ETHERSCAN_API_KEY) {
                    log('âœ… Etherscan API key configured', 'success');
                } else {
                    log('âš ï¸ Etherscan API key not set - click âš™ï¸ Config', 'warn');
                }
                
                if (!SUPABASE_URL || !SUPABASE_ANON_KEY) {
                    document.getElementById('connStatus').className = 'connection-status disconnected';
                    document.getElementById('connText').textContent = 'Not Configured';
                    log('âš ï¸ Supabase not configured - click âš™ï¸ Config', 'warn');
                    return;
                }
                
                // SDK ë¡œë“œ ì²´í¬
                if (!window.supabase) {
                    document.getElementById('connStatus').className = 'connection-status disconnected';
                    document.getElementById('connText').textContent = 'SDK Error';
                    log('âŒ Supabase SDK not loaded', 'error');
                    return;
                }
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                await supabase.from('historical_eth_price').select('date').limit(1);
                document.getElementById('connStatus').className = 'connection-status connected';
                document.getElementById('connText').textContent = 'Connected';
                log('âœ… Supabase connected', 'success');
                await loadDataStatus();
                
                // Auto-collect if more than 12 hours since last collection
                await checkAutoCollect();
            } catch (e) {
                document.getElementById('connStatus').className = 'connection-status disconnected';
                document.getElementById('connText').textContent = 'Error';
                log('âŒ Init error: ' + e.message, 'error');
                console.error('Init error:', e);
            }
        }
        
        // Check if auto-collection is needed (every 12 hours)
        async function checkAutoCollect() {
            const lastCollect = localStorage.getItem('ethval_last_collect');
            const now = Date.now();
            const TWELVE_HOURS = 12 * 60 * 60 * 1000;
            
            if (!lastCollect || (now - parseInt(lastCollect)) > TWELVE_HOURS) {
                log('\nâ° Auto-collection triggered (>12h since last run)', 'info');
                localStorage.setItem('ethval_last_collect', now.toString());
                
                // Run collection after a short delay
                setTimeout(async () => {
                    await collectAll();
                }, 2000);
            } else {
                const hoursAgo = ((now - parseInt(lastCollect)) / (60 * 60 * 1000)).toFixed(1);
                log(`â° Last collection: ${hoursAgo}h ago (auto-collect in ${(12 - hoursAgo).toFixed(1)}h)`, 'info');
            }
        }
        
        // DOM ë¡œë“œ í›„ ì‹¤í–‰
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
